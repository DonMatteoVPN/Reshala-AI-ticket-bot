#!/usr/bin/env python3
"""
Telegram –±–æ—Ç –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ Remnawave
–ü–æ–∑–≤–æ–ª—è–µ—Ç –ø–æ–ª—É—á–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è—Ö –∏ –∏—Ö –ø–æ–¥–ø–∏—Å–∫–∞—Ö –ø–æ Telegram ID –∏–ª–∏ username
"""

import os
import base64
import tempfile

# –ó–∞–≥—Ä—É–∂–∞–µ–º .env –¥–æ –∏–º–ø–æ—Ä—Ç–∞ ai_support, —á—Ç–æ–±—ã GROQ_API_KEY –∏ –¥—Ä. –±—ã–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã
try:
    from dotenv import load_dotenv
    load_dotenv()
except ImportError:
    pass

import logging
import time
import requests
from datetime import datetime
from typing import Optional, Dict, Any, List
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, WebAppInfo, MenuButtonWebApp, MenuButtonCommands
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
    ContextTypes,
    PicklePersistence,
)

try:
    from payments.freekassa import get_freekassa_provider
    from payments.storage import pending_add
    _PAYMENTS_AVAILABLE = True
except ImportError:
    _PAYMENTS_AVAILABLE = False
    get_freekassa_provider = None
    pending_add = None

try:
    from ai_support import (
        is_ai_enabled,
        build_client_context_for_ai,
        get_system_prompt,
        get_conversation_history,
        add_to_conversation_history,
        get_last_user_message,
        add_global_example,
        transcribe_voice_groq,
        get_ai_reply,
        check_ai_key_at_startup,
        AI_PROVIDER,
    )
    _AI_SUPPORT_AVAILABLE = True
except ImportError:
    _AI_SUPPORT_AVAILABLE = False
    check_ai_key_at_startup = lambda: False
    is_ai_enabled = lambda: False
    build_client_context_for_ai = None
    get_system_prompt = None
    get_conversation_history = lambda bot_data, client_id: []
    add_to_conversation_history = lambda bot_data, client_id, role, content: None
    get_last_user_message = lambda bot_data, client_id: None
    add_global_example = lambda bot_data, user_msg, assistant_msg: None
    transcribe_voice_groq = None
    get_ai_reply = None
    AI_PROVIDER = "groq"

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
BOT_TOKEN = os.getenv('BOT_TOKEN')
REMNAWAVE_API_URL = os.getenv('REMNAWAVE_API_URL', '').rstrip('/')
REMNAWAVE_API_TOKEN = os.getenv('REMNAWAVE_API_TOKEN')
BEDOLAGA_API_URL = (os.getenv('BEDOLAGA_API_URL') or '').strip().rstrip('/')
BEDOLAGA_API_TOKEN = (os.getenv('BEDOLAGA_API_TOKEN') or '').strip()
ALLOWED_MANAGER_IDS = set(
    int(id.strip()) for id in os.getenv('ALLOWED_MANAGER_IDS', '').split(',') if id.strip()
)
MINI_APP_DOMAIN = (os.getenv('MINI_APP_DOMAIN') or '').strip()
MINI_APP_URL = ('https://' + MINI_APP_DOMAIN) if MINI_APP_DOMAIN else ''
SERVICE_NAME = (os.getenv('SERVICE_NAME') or 'Remnawave').strip() or 'Remnawave'
_SUPPORT_GROUP_RAW = (os.getenv('SUPPORT_GROUP_ID') or '').strip()
SUPPORT_GROUP_ID = int(_SUPPORT_GROUP_RAW) if _SUPPORT_GROUP_RAW else None


def _support_chat_ids():
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ chat_id –¥–ª—è –ø–æ–ø—ã—Ç–∫–∏ (–ø–æ–ª–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—É–ø–µ—Ä–≥—Ä—É–ø–ø—ã –∏ –∫–∞–∫ –≤ .env)."""
    if SUPPORT_GROUP_ID is None:
        return []
    ids = [SUPPORT_GROUP_ID]
    # –í API —Å—É–ø–µ—Ä–≥—Ä—É–ø–ø—ã —á–∞—Å—Ç–æ –∏–º–µ—é—Ç id –≤–∏–¥–∞ -100xxxxxxxxxx; –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω –∫–æ—Ä–æ—Ç–∫–∏–π -N, –ø—Ä–æ–±—É–µ–º -100N
    if -10**9 <= SUPPORT_GROUP_ID < 0 and SUPPORT_GROUP_ID > -10**10:
        full_id = -(10**12 + abs(SUPPORT_GROUP_ID))
        if full_id not in ids:
            ids.append(full_id)
    return ids

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
if not BOT_TOKEN:
    raise ValueError("BOT_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
if not REMNAWAVE_API_URL:
    raise ValueError("REMNAWAVE_API_URL –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
if not REMNAWAVE_API_TOKEN:
    raise ValueError("REMNAWAVE_API_TOKEN –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
if not ALLOWED_MANAGER_IDS:
    raise ValueError("ALLOWED_MANAGER_IDS –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω (–¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω ID)")


def check_access(user_id: int) -> bool:
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –º–µ–Ω–µ–¥–∂–µ—Ä–∞"""
    return user_id in ALLOWED_MANAGER_IDS


def _bedolaga_configured() -> bool:
    """–ü—Ä–æ–≤–µ—Ä–∫–∞, –Ω–∞—Å—Ç—Ä–æ–µ–Ω –ª–∏ –≤–µ–±-API Bedolaga (–±–∞–ª–∞–Ω—Å –∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏)."""
    return bool(BEDOLAGA_API_URL and BEDOLAGA_API_TOKEN)


def get_bedolaga_user(telegram_id: str) -> Optional[Dict[str, Any]]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –≤–µ–±-API Bedolaga –ø–æ Telegram ID. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ —Å balance_* –∏ id."""
    if not _bedolaga_configured():
        return None
    try:
        url = f"{BEDOLAGA_API_URL}/users/{telegram_id}"
        headers = {"X-API-Key": BEDOLAGA_API_TOKEN}
        response = requests.get(url, headers=headers, timeout=10)
        if response.status_code == 200:
            return response.json()
        if response.status_code == 404:
            return None
        logger.warning("Bedolaga API users: %s %s", response.status_code, response.text[:200])
        return None
    except Exception as e:
        logger.warning("get_bedolaga_user %s: %s", telegram_id, e)
        return None


def get_bedolaga_transactions(bedolaga_user_id: int, limit: int = 30) -> List[Dict[str, Any]]:
    """–°–ø–∏—Å–æ–∫ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –≤–µ–±-API Bedolaga (user_id ‚Äî –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π id –∏–∑ Bedolaga)."""
    if not _bedolaga_configured():
        return []
    try:
        url = f"{BEDOLAGA_API_URL}/transactions"
        headers = {"X-API-Key": BEDOLAGA_API_TOKEN}
        params = {"user_id": bedolaga_user_id, "limit": limit, "offset": 0}
        response = requests.get(url, headers=headers, params=params, timeout=10)
        if response.status_code != 200:
            logger.warning("Bedolaga API transactions: %s %s", response.status_code, response.text[:200])
            return []
        data = response.json()
        return data.get("items") or []
    except Exception as e:
        logger.warning("get_bedolaga_transactions %s: %s", bedolaga_user_id, e)
        return []


def _format_bedolaga_balance(bedolaga_user: Dict[str, Any]) -> str:
    """–°—Ç—Ä–æ–∫–∞ –±–∞–ª–∞–Ω—Å–∞ –∏–∑ –æ—Ç–≤–µ—Ç–∞ Bedolaga (balance_rubles –∏–ª–∏ balance_kopeks)."""
    rub = bedolaga_user.get("balance_rubles")
    if rub is not None:
        return f"{float(rub):.2f}"
    kopeks = bedolaga_user.get("balance_kopeks", 0)
    return f"{int(kopeks) / 100:.2f}"


def _format_bedolaga_transactions_message(transactions: List[Dict[str, Any]], max_len: int = 3800) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π Bedolaga –≤ –æ–¥–∏–Ω —Ç–µ–∫—Å—Ç (–æ–±—Ä–µ–∑–∞–µ—Ç –ø–æ max_len)."""
    if not transactions:
        return "üìú <b>–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ (Bedolaga)</b>\n\n–ù–µ—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π."
    lines = ["üìú <b>–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ (Bedolaga)</b>\n"]
    for t in transactions:
        amount = t.get("amount_rubles") or (t.get("amount_kopeks", 0) / 100)
        typ = t.get("type") or "‚Äî"
        desc = (t.get("description") or "‚Äî")[:50]
        created = (t.get("created_at") or "‚Äî")[:19].replace("T", " ")
        lines.append(f"‚Ä¢ {created} ¬∑ {amount:.2f} ‚ÇΩ ¬∑ {typ}\n  {desc}")
    text = "\n".join(lines)
    if len(text) > max_len:
        text = text[: max_len - 50] + "\n\n‚Ä¶ (–ø–æ–∫–∞–∑–∞–Ω—ã –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∑–∞–ø–∏—Å–∏)"
    return text


def _set_awaiting_invoice_by_manager(context: ContextTypes.DEFAULT_TYPE, manager_id: int, payload: dict) -> None:
    """–î—É–±–ª–∏—Ä—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ ¬´–æ–∂–∏–¥–∞–Ω–∏–µ —Å—É–º–º—ã¬ª –≤ bot_data, —á—Ç–æ–±—ã —Ä–∞–±–æ—Ç–∞–ª–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö (—Ç–æ–ø–∏–∫–∏)."""
    if not getattr(context.application, "bot_data", None):
        return
    bot_data = context.application.bot_data
    key = "awaiting_invoice_by_manager"
    if key not in bot_data:
        bot_data[key] = {}
    bot_data[key][manager_id] = payload


def _get_awaiting_invoice(context: ContextTypes.DEFAULT_TYPE, manager_id: int) -> Optional[dict]:
    """–ü–æ–ª—É—á–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ ¬´–æ–∂–∏–¥–∞–Ω–∏–µ —Å—É–º–º—ã¬ª –∏–∑ user_data –∏–ª–∏ bot_data (–¥–ª—è –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–æ–≤)."""
    awaiting = (context.user_data or {}).get("awaiting_invoice")
    if awaiting:
        return awaiting
    bot_data = getattr(context.application, "bot_data", None) or {}
    by_manager = bot_data.get("awaiting_invoice_by_manager") or {}
    return by_manager.get(manager_id)


def _clear_awaiting_invoice(context: ContextTypes.DEFAULT_TYPE, manager_id: int) -> None:
    """–û—á–∏—Å—Ç–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ ¬´–æ–∂–∏–¥–∞–Ω–∏–µ —Å—É–º–º—ã¬ª –≤ user_data –∏ bot_data."""
    context.user_data.pop("awaiting_invoice", None)
    bot_data = getattr(context.application, "bot_data", None)
    if bot_data:
        by_manager = bot_data.get("awaiting_invoice_by_manager")
        if by_manager is not None and manager_id in by_manager:
            del by_manager[manager_id]


def format_bytes(bytes_value: int) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –±–∞–π—Ç–æ–≤ –≤ —á–∏—Ç–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç"""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if bytes_value < 1024.0:
            return f"{bytes_value:.2f} {unit}"
        bytes_value /= 1024.0
    return f"{bytes_value:.2f} PB"


def format_datetime(dt_str: Optional[str]) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞—Ç—ã –∏ –≤—Ä–µ–º–µ–Ω–∏"""
    if not dt_str:
        return "–ù–µ —É–∫–∞–∑–∞–Ω–æ"
    try:
        dt = datetime.fromisoformat(dt_str.replace('Z', '+00:00'))
        return dt.strftime('%d.%m.%Y %H:%M:%S')
    except:
        return dt_str


def get_user_by_telegram_id(telegram_id: str) -> Optional[Dict[str, Any]]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ Telegram ID. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç response –∫–∞–∫ –º–∞—Å—Å–∏–≤ –∏–ª–∏ –æ–¥–∏–Ω –æ–±—ä–µ–∫—Ç."""
    try:
        url = f"{REMNAWAVE_API_URL}/api/users/by-telegram-id/{telegram_id}"
        headers = {"Authorization": f"Bearer {REMNAWAVE_API_TOKEN}"}
        response = requests.get(url, headers=headers, timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            raw = data.get("response")
            if raw is None:
                return None
            # API –º–æ–∂–µ—Ç –≤–µ—Ä–Ω—É—Ç—å –º–∞—Å—Å–∏–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏–ª–∏ –æ–¥–∏–Ω –æ–±—ä–µ–∫—Ç
            if isinstance(raw, list):
                return raw[0] if raw else None
            if isinstance(raw, dict) and raw.get("uuid"):
                return raw
            return None
        elif response.status_code == 404:
            return None
        else:
            logger.error(
                "–û—à–∏–±–∫–∞ API –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ Telegram ID: %s, body=%s",
                response.status_code,
                response.text[:500] if response.text else "",
            )
            return None
    except Exception as e:
        logger.error("–ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ Telegram ID %s: %s", telegram_id, e)
        return None


def get_user_by_username(username: str) -> Optional[Dict[str, Any]]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ username"""
    try:
        url = f"{REMNAWAVE_API_URL}/api/users/by-username/{username}"
        headers = {"Authorization": f"Bearer {REMNAWAVE_API_TOKEN}"}
        response = requests.get(url, headers=headers, timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            return data.get('response')
        elif response.status_code == 404:
            return None
        else:
            logger.error(f"–û—à–∏–±–∫–∞ API –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ username: {response.status_code}")
            return None
    except Exception as e:
        logger.error(f"–ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ username: {e}")
        return None


def get_subscription_by_uuid(uuid: str) -> Optional[Dict[str, Any]]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ UUID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        url = f"{REMNAWAVE_API_URL}/api/subscriptions/by-uuid/{uuid}"
        headers = {"Authorization": f"Bearer {REMNAWAVE_API_TOKEN}"}
        response = requests.get(url, headers=headers, timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            return data.get('response')
        elif response.status_code == 404:
            return None
        else:
            logger.error(f"–û—à–∏–±–∫–∞ API –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–¥–ø–∏—Å–∫–∏: {response.status_code}")
            return None
    except Exception as e:
        logger.error(f"–ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–¥–ø–∏—Å–∫–∏: {e}")
        return None


def get_subscription_page_configs() -> Optional[List[Dict[str, Any]]]:
    """–°–ø–∏—Å–æ–∫ —Ç–∞—Ä–∏—Ñ–æ–≤ (–∫–æ–Ω—Ñ–∏–≥–æ–≤ —Å—Ç—Ä–∞–Ω–∏—Ü—ã –ø–æ–¥–ø–∏—Å–∫–∏) –∏–∑ API ‚Äî –¥–ª—è –≤—ã–¥–∞—á–∏ –∫–ª–∏–µ–Ω—Ç—É –ø–æ –∑–∞–ø—Ä–æ—Å—É ¬´–∫–∞–∫–∏–µ —Ç–∞—Ä–∏—Ñ—ã¬ª."""
    try:
        url = f"{REMNAWAVE_API_URL}/api/subscription-page-configs"
        headers = {"Authorization": f"Bearer {REMNAWAVE_API_TOKEN}"}
        response = requests.get(url, headers=headers, timeout=10)
        if response.status_code != 200:
            return None
        data = response.json()
        resp = data.get("response") or {}
        configs = resp.get("configs") or []
        return configs if isinstance(configs, list) else None
    except Exception as e:
        logger.debug("get_subscription_page_configs: %s", e)
        return None


def get_hwid_devices(user_uuid: str) -> Optional[List[Dict[str, Any]]]:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ HWID —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        url = f"{REMNAWAVE_API_URL}/api/hwid/devices/{user_uuid}"
        headers = {"Authorization": f"Bearer {REMNAWAVE_API_TOKEN}"}
        response = requests.get(url, headers=headers, timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            response_data = data.get('response', {})
            devices = response_data.get('devices', [])
            return devices
        elif response.status_code == 404:
            return []
        else:
            logger.error(f"–û—à–∏–±–∫–∞ API –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ HWID —É—Å—Ç—Ä–æ–π—Å—Ç–≤: {response.status_code}")
            return None
    except Exception as e:
        logger.error(f"–ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ HWID —É—Å—Ç—Ä–æ–π—Å—Ç–≤: {e}")
        return None


def api_reset_user_traffic(user_uuid: str) -> tuple:
    """–°–±—Ä–æ—Å —Ç—Ä–∞—Ñ–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (—É—Å–ø–µ—Ö, —Å–æ–æ–±—â–µ–Ω–∏–µ)."""
    try:
        url = f"{REMNAWAVE_API_URL}/api/users/{user_uuid}/actions/reset-traffic"
        r = requests.post(url, headers={"Authorization": f"Bearer {REMNAWAVE_API_TOKEN}"}, timeout=15)
        if r.status_code == 200:
            return True, "–¢—Ä–∞—Ñ–∏–∫ —Å–±—Ä–æ—à–µ–Ω."
        return False, f"–û—à–∏–±–∫–∞ API: {r.status_code}"
    except Exception as e:
        logger.exception("reset_user_traffic")
        return False, str(e)


def api_revoke_user_subscription(user_uuid: str) -> tuple:
    """–ü–µ—Ä–µ–≤—ã–ø—É—Å–∫ –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (—É—Å–ø–µ—Ö, —Å–æ–æ–±—â–µ–Ω–∏–µ)."""
    try:
        url = f"{REMNAWAVE_API_URL}/api/users/{user_uuid}/actions/revoke"
        r = requests.post(url, json={}, headers={"Authorization": f"Bearer {REMNAWAVE_API_TOKEN}"}, timeout=15)
        if r.status_code == 200:
            return True, "–ü–æ–¥–ø–∏—Å–∫–∞ –ø–µ—Ä–µ–≤—ã–ø—É—â–µ–Ω–∞."
        return False, f"–û—à–∏–±–∫–∞ API: {r.status_code}"
    except Exception as e:
        logger.exception("revoke_user_subscription")
        return False, str(e)


def api_delete_hwid_device(user_uuid: str, hwid: str) -> tuple:
    """–£–¥–∞–ª–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ HWID —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (—É—Å–ø–µ—Ö, —Å–æ–æ–±—â–µ–Ω–∏–µ)."""
    try:
        url = f"{REMNAWAVE_API_URL}/api/hwid/devices/delete"
        r = requests.post(url, json={"userUuid": user_uuid, "hwid": hwid}, headers={"Authorization": f"Bearer {REMNAWAVE_API_TOKEN}"}, timeout=15)
        if r.status_code == 200:
            return True, "–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ —É–¥–∞–ª–µ–Ω–æ."
        return False, f"–û—à–∏–±–∫–∞ API: {r.status_code}"
    except Exception as e:
        logger.exception("delete_hwid_device")
        return False, str(e)


def api_delete_all_hwid(user_uuid: str) -> tuple:
    """–£–¥–∞–ª–µ–Ω–∏–µ –≤—Å–µ—Ö HWID —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (—É—Å–ø–µ—Ö, —Å–æ–æ–±—â–µ–Ω–∏–µ)."""
    try:
        url = f"{REMNAWAVE_API_URL}/api/hwid/devices/delete-all"
        r = requests.post(url, json={"userUuid": user_uuid}, headers={"Authorization": f"Bearer {REMNAWAVE_API_TOKEN}"}, timeout=15)
        if r.status_code == 200:
            return True, "–í—Å–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ —É–¥–∞–ª–µ–Ω—ã."
        return False, f"–û—à–∏–±–∫–∞ API: {r.status_code}"
    except Exception as e:
        logger.exception("delete_all_hwid")
        return False, str(e)


def api_disable_user(user_uuid: str) -> tuple:
    """–û—Ç–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ Remnawave. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (—É—Å–ø–µ—Ö, —Å–æ–æ–±—â–µ–Ω–∏–µ)."""
    try:
        url = f"{REMNAWAVE_API_URL}/api/users/{user_uuid}/actions/disable"
        r = requests.post(url, json={}, headers={"Authorization": f"Bearer {REMNAWAVE_API_TOKEN}"}, timeout=15)
        if r.status_code == 200:
            return True, "–ü—Ä–æ—Ñ–∏–ª—å –æ—Ç–∫–ª—é—á—ë–Ω (–∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω)."
        return False, f"–û—à–∏–±–∫–∞ API: {r.status_code}"
    except Exception as e:
        logger.exception("disable_user")
        return False, str(e)


def api_enable_user(user_uuid: str) -> tuple:
    """–í–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ Remnawave. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (—É—Å–ø–µ—Ö, —Å–æ–æ–±—â–µ–Ω–∏–µ)."""
    try:
        url = f"{REMNAWAVE_API_URL}/api/users/{user_uuid}/actions/enable"
        r = requests.post(url, json={}, headers={"Authorization": f"Bearer {REMNAWAVE_API_TOKEN}"}, timeout=15)
        if r.status_code == 200:
            return True, "–ü—Ä–æ—Ñ–∏–ª—å –≤–∫–ª—é—á—ë–Ω (—Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω)."
        return False, f"–û—à–∏–±–∫–∞ API: {r.status_code}"
    except Exception as e:
        logger.exception("enable_user")
        return False, str(e)


def get_internal_squads() -> Optional[List[Dict[str, Any]]]:
    """–°–ø–∏—Å–æ–∫ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö —Å–∫–≤–∞–¥–æ–≤ Remnawave."""
    try:
        url = f"{REMNAWAVE_API_URL}/api/internal-squads"
        r = requests.get(url, headers={"Authorization": f"Bearer {REMNAWAVE_API_TOKEN}"}, timeout=10)
        if r.status_code != 200:
            return None
        data = r.json()
        resp = data.get("response") or {}
        return resp.get("internalSquads") or []
    except Exception as e:
        logger.exception("get_internal_squads: %s", e)
        return None


def get_external_squads() -> Optional[List[Dict[str, Any]]]:
    """–°–ø–∏—Å–æ–∫ –≤–Ω–µ—à–Ω–∏—Ö —Å–∫–≤–∞–¥–æ–≤ Remnawave."""
    try:
        url = f"{REMNAWAVE_API_URL}/api/external-squads"
        r = requests.get(url, headers={"Authorization": f"Bearer {REMNAWAVE_API_TOKEN}"}, timeout=10)
        if r.status_code != 200:
            return None
        data = r.json()
        resp = data.get("response") or {}
        return resp.get("externalSquads") or []
    except Exception as e:
        logger.exception("get_external_squads: %s", e)
        return None


def add_user_to_internal_squad(squad_uuid: str, user_uuid: str) -> tuple:
    """–î–æ–±–∞–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Å–∫–≤–∞–¥. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (—É—Å–ø–µ—Ö, —Å–æ–æ–±—â–µ–Ω–∏–µ)."""
    try:
        url = f"{REMNAWAVE_API_URL}/api/internal-squads/{squad_uuid}/bulk-actions/add-users"
        r = requests.post(
            url,
            json={"userUuids": [user_uuid]},
            headers={"Authorization": f"Bearer {REMNAWAVE_API_TOKEN}"},
            timeout=15,
        )
        if r.status_code == 200:
            return True, "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω –≤–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Å–∫–≤–∞–¥."
        return False, f"–û—à–∏–±–∫–∞ API: {r.status_code}"
    except Exception as e:
        logger.exception("add_user_to_internal_squad")
        return False, str(e)


def add_user_to_external_squad(squad_uuid: str, user_uuid: str) -> tuple:
    """–î–æ–±–∞–≤–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤–æ –≤–Ω–µ—à–Ω–∏–π —Å–∫–≤–∞–¥ (–≤—ã–¥–∞—Ç—å —Å–∫–≤–∞–¥ –∫–ª–∏–µ–Ω—Ç—É). –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (—É—Å–ø–µ—Ö, —Å–æ–æ–±—â–µ–Ω–∏–µ)."""
    try:
        url = f"{REMNAWAVE_API_URL}/api/external-squads/{squad_uuid}/bulk-actions/add-users"
        r = requests.post(
            url,
            json={"userUuids": [user_uuid]},
            headers={"Authorization": f"Bearer {REMNAWAVE_API_TOKEN}"},
            timeout=15,
        )
        if r.status_code == 200:
            return True, "–°–∫–≤–∞–¥ –≤—ã–¥–∞–Ω –∫–ª–∏–µ–Ω—Ç—É."
        return False, f"–û—à–∏–±–∫–∞ API: {r.status_code}"
    except Exception as e:
        logger.exception("add_user_to_external_squad")
        return False, str(e)


def _is_user_disabled(user: Dict[str, Any], subscription: Optional[Dict[str, Any]]) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å (–ø–æ status / userStatus)."""
    status = (user or {}).get("status") or ""
    sub_user = (subscription or {}).get("user", {}) if subscription else {}
    user_status = sub_user.get("userStatus") or ""
    disabled_values = ("DISABLED", "INACTIVE", "DEACTIVATED", "BANNED", "disabled", "inactive")
    return status.upper() in disabled_values or user_status.upper() in disabled_values


# –ö–ª—é—á–∏ —Å–µ–∫—Ü–∏–π –¥–ª—è –∫–Ω–æ–ø–æ–∫ (callback_data –¥–æ 64 –±–∞–π—Ç)
SECTIONS = ('profile', 'traffic', 'dates', 'subscription', 'hwid')


def _section_profile(user: Dict[str, Any]) -> str:
    """–¢–µ–∫—Å—Ç —Å–µ–∫—Ü–∏–∏: –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    lines = [
        "üë§ <b>–ü–†–û–§–ò–õ–¨</b>\n",
        f"üÜî <b>UUID:</b> <code>{user.get('uuid', 'N/A')}</code>",
        f"üìù <b>Short UUID:</b> <code>{user.get('shortUuid', 'N/A')}</code>",
        f"üî¢ <b>ID:</b> {user.get('id', 'N/A')}",
        f"üë§ <b>Username:</b> @{user.get('username', 'N/A')}",
        f"üìß <b>Email:</b> {user.get('email') or '–ù–µ —É–∫–∞–∑–∞–Ω'}",
        f"üí¨ <b>Telegram ID:</b> {user.get('telegramId') or '–ù–µ —É–∫–∞–∑–∞–Ω'}",
        f"üìä <b>–°—Ç–∞—Ç—É—Å:</b> {user.get('status', 'N/A')}",
        f"üè∑Ô∏è <b>–¢–µ–≥:</b> {user.get('tag') or '–ù–µ —É–∫–∞–∑–∞–Ω'}",
        f"üìÑ <b>–û–ø–∏—Å–∞–Ω–∏–µ:</b> {user.get('description') or '–ù–µ —É–∫–∞–∑–∞–Ω–æ'}",
    ]
    if user.get('hwidDeviceLimit'):
        lines.append(f"üì± <b>–õ–∏–º–∏—Ç —É—Å—Ç—Ä–æ–π—Å—Ç–≤:</b> {user.get('hwidDeviceLimit')}")
    if user.get('subLastUserAgent'):
        lines.append(f"üåê <b>–ü–æ—Å–ª–µ–¥–Ω–∏–π User-Agent:</b> {user.get('subLastUserAgent')}")
    active_squads = user.get('activeInternalSquads', [])
    if active_squads:
        lines.append("\nüë• <b>–ê–∫—Ç–∏–≤–Ω—ã–µ —Å–∫–≤–∞–¥—ã:</b>")
        for squad in active_squads:
            lines.append(f"  ‚Ä¢ {squad.get('name', 'N/A')}")
    return "\n".join(lines)


def _section_traffic(user: Dict[str, Any]) -> str:
    """–¢–µ–∫—Å—Ç —Å–µ–∫—Ü–∏–∏: —Ç—Ä–∞—Ñ–∏–∫"""
    lines = ["üìä <b>–¢–†–ê–§–ò–ö</b>\n"]
    user_traffic = user.get('userTraffic', {})
    if user_traffic:
        used = user_traffic.get('usedTrafficBytes', 0)
        lifetime = user_traffic.get('lifetimeUsedTrafficBytes', 0)
        limit = user.get('trafficLimitBytes', 0)
        lines.extend([
            f"üì• <b>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ:</b> {format_bytes(used)}",
            f"üìà <b>–í—Å–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ:</b> {format_bytes(lifetime)}",
            f"üìä <b>–õ–∏–º–∏—Ç:</b> {format_bytes(limit) if limit > 0 else '–ë–µ–∑–ª–∏–º–∏—Ç'}",
            f"üîÑ <b>–°—Ç—Ä–∞—Ç–µ–≥–∏—è —Å–±—Ä–æ—Å–∞:</b> {user.get('trafficLimitStrategy', 'NO_RESET')}",
        ])
        if user_traffic.get('onlineAt'):
            lines.append(f"üü¢ <b>–û–Ω–ª–∞–π–Ω:</b> {format_datetime(user_traffic.get('onlineAt'))}")
        if user_traffic.get('firstConnectedAt'):
            lines.append(f"üîå <b>–ü–µ—Ä–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ:</b> {format_datetime(user_traffic.get('firstConnectedAt'))}")
    else:
        lines.append("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ —Ç—Ä–∞—Ñ–∏–∫–µ.")
    return "\n".join(lines)


def _section_dates(user: Dict[str, Any]) -> str:
    """–¢–µ–∫—Å—Ç —Å–µ–∫—Ü–∏–∏: –¥–∞—Ç—ã"""
    lines = [
        "üìÖ <b>–î–ê–¢–´</b>\n",
        f"‚è∞ <b>–ò—Å—Ç–µ–∫–∞–µ—Ç:</b> {format_datetime(user.get('expireAt'))}",
        f"üìÖ <b>–°–æ–∑–¥–∞–Ω:</b> {format_datetime(user.get('createdAt'))}",
        f"üîÑ <b>–û–±–Ω–æ–≤–ª–µ–Ω:</b> {format_datetime(user.get('updatedAt'))}",
    ]
    if user.get('subRevokedAt'):
        lines.append(f"üö´ <b>–ü–æ–¥–ø–∏—Å–∫–∞ –æ—Ç–æ–∑–≤–∞–Ω–∞:</b> {format_datetime(user.get('subRevokedAt'))}")
    if user.get('subLastOpenedAt'):
        lines.append(f"üì± <b>–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ—Ç–∫—Ä—ã—Ç–∏–µ:</b> {format_datetime(user.get('subLastOpenedAt'))}")
    if user.get('lastTrafficResetAt'):
        lines.append(f"üîÑ <b>–ü–æ—Å–ª–µ–¥–Ω–∏–π —Å–±—Ä–æ—Å —Ç—Ä–∞—Ñ–∏–∫–∞:</b> {format_datetime(user.get('lastTrafficResetAt'))}")
    return "\n".join(lines)


def _section_subscription(subscription: Optional[Dict[str, Any]]) -> str:
    """–¢–µ–∫—Å—Ç —Å–µ–∫—Ü–∏–∏: –ø–æ–¥–ø–∏—Å–∫–∞"""
    lines = ["üîó <b>–ü–û–î–ü–ò–°–ö–ê</b>\n"]
    if not subscription:
        lines.append("–î–∞–Ω–Ω—ã–µ –æ –ø–æ–¥–ø–∏—Å–∫–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã.")
        return "\n".join(lines)
    sub_user = subscription.get('user', {})
    lines.append(f"‚úÖ <b>–ù–∞–π–¥–µ–Ω–∞:</b> {'–î–∞' if subscription.get('isFound') else '–ù–µ—Ç'}")
    if sub_user:
        lines.extend([
            f"üìä <b>–î–Ω–µ–π –æ—Å—Ç–∞–ª–æ—Å—å:</b> {sub_user.get('daysLeft', 'N/A')}",
            f"üì• <b>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ:</b> {sub_user.get('trafficUsed', 'N/A')}",
            f"üìä <b>–õ–∏–º–∏—Ç:</b> {sub_user.get('trafficLimit', 'N/A')}",
            f"üìà <b>–í—Å–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ:</b> {sub_user.get('lifetimeTrafficUsed', 'N/A')}",
            f"‚úÖ <b>–ê–∫—Ç–∏–≤–Ω–∞:</b> {'–î–∞' if sub_user.get('isActive') else '–ù–µ—Ç'}",
            f"üìä <b>–°—Ç–∞—Ç—É—Å:</b> {sub_user.get('userStatus', 'N/A')}",
        ])
    url = subscription.get('subscriptionUrl')
    if url:
        lines.append(f"\nüîó <b>URL –ø–æ–¥–ø–∏—Å–∫–∏:</b>\n<code>{url}</code>")
    return "\n".join(lines)


def _section_hwid(hwid_devices: Optional[List[Dict[str, Any]]]) -> str:
    """–¢–µ–∫—Å—Ç —Å–µ–∫—Ü–∏–∏: HWID —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞"""
    lines = ["üì± <b>–ü–†–ò–í–Ø–ó–ê–ù–ù–´–ï –£–°–¢–†–û–ô–°–¢–í–ê (HWID)</b>\n"]
    if hwid_devices is None:
        lines.append("–î–∞–Ω–Ω—ã–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã.")
        return "\n".join(lines)
    if not hwid_devices:
        lines.append("–£—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
        return "\n".join(lines)
    lines.append(f"–í—Å–µ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤: {len(hwid_devices)}\n")
    for i, device in enumerate(hwid_devices, 1):
        lines.append(f"<b>–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ {i}:</b>")
        lines.append(f"  üîë <b>HWID:</b> <code>{device.get('hwid', 'N/A')}</code>")
        if device.get('platform'):
            lines.append(f"  üì± <b>–ü–ª–∞—Ç—Ñ–æ—Ä–º–∞:</b> {device.get('platform')}")
        if device.get('osVersion'):
            lines.append(f"  üíª <b>–û–°:</b> {device.get('osVersion')}")
        if device.get('deviceModel'):
            lines.append(f"  üñ•Ô∏è <b>–ú–æ–¥–µ–ª—å:</b> {device.get('deviceModel')}")
        if device.get('userAgent'):
            ua = device.get('userAgent', '')
            lines.append(f"  üåê <b>User-Agent:</b> {ua[:60]}{'...' if len(ua) > 60 else ''}")
        if device.get('createdAt'):
            lines.append(f"  üìÖ <b>–î–æ–±–∞–≤–ª–µ–Ω–æ:</b> {format_datetime(device.get('createdAt'))}")
        if device.get('updatedAt'):
            lines.append(f"  üîÑ <b>–û–±–Ω–æ–≤–ª–µ–Ω–æ:</b> {format_datetime(device.get('updatedAt'))}")
        if i < len(hwid_devices):
            lines.append("")
    return "\n".join(lines)


def get_section_text(section: str, user: Dict[str, Any], subscription: Optional[Dict[str, Any]], hwid_devices: Optional[List[Dict[str, Any]]]) -> str:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—Å—Ç –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Å–µ–∫—Ü–∏–∏."""
    if section == 'profile':
        return _section_profile(user)
    if section == 'traffic':
        return _section_traffic(user)
    if section == 'dates':
        return _section_dates(user)
    if section == 'subscription':
        return _section_subscription(subscription)
    if section == 'hwid':
        return _section_hwid(hwid_devices)
    return "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Å–µ–∫—Ü–∏—è."


def build_section_keyboard(current_section: str, last_user_data: Optional[Dict[str, Any]] = None) -> InlineKeyboardMarkup:
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –ø–æ —Å–µ–∫—Ü–∏—è–º + –¥–µ–π—Å—Ç–≤–∏—è (—Å–±—Ä–æ—Å —Ç—Ä–∞—Ñ–∏–∫–∞, –ø–µ—Ä–µ–≤—ã–ø—É—Å–∫, HWID)."""
    labels = [
        ("üë§ –ü—Ä–æ—Ñ–∏–ª—å", "profile"),
        ("üìä –¢—Ä–∞—Ñ–∏–∫", "traffic"),
        ("üìÖ –î–∞—Ç—ã", "dates"),
        ("üîó –ü–æ–¥–ø–∏—Å–∫–∞", "subscription"),
        ("üì± –£—Å—Ç—Ä–æ–π—Å—Ç–≤–∞", "hwid"),
    ]
    row1, row2 = [], []
    for i, (label, section) in enumerate(labels):
        text = f"‚úì {label}" if section == current_section else label
        btn = InlineKeyboardButton(text=text, callback_data=f"s:{section}")
        if i < 3:
            row1.append(btn)
        else:
            row2.append(btn)
    rows = [row1, row2]
    # –î–µ–π—Å—Ç–≤–∏—è (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)
    if last_user_data and last_user_data.get("user", {}).get("uuid"):
        user = last_user_data.get("user", {})
        sub = last_user_data.get("subscription")
        block_btn = (
            InlineKeyboardButton("üîì –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å", callback_data="act:enable")
            if _is_user_disabled(user, sub)
            else InlineKeyboardButton("üîí –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å", callback_data="act:disable")
        )
        rows.append([
            InlineKeyboardButton("üîÑ –°–±—Ä–æ—Å —Ç—Ä–∞—Ñ–∏–∫–∞", callback_data="act:reset_traffic"),
            InlineKeyboardButton("üîó –ü–µ—Ä–µ–≤—ã–ø—É—Å–∫ –ø–æ–¥–ø–∏—Å–∫–∏", callback_data="act:revoke_sub"),
        ])
        invoice_btn = InlineKeyboardButton("üí∞ –í—ã—Å—Ç–∞–≤–∏—Ç—å —Å—á—ë—Ç", callback_data="act:invoice")
        rows.append([block_btn, invoice_btn])
        if last_user_data.get("bedolaga_user"):
            rows.append([InlineKeyboardButton("üìú –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ (Bedolaga)", callback_data="act:bedolaga_tx")])
        rows.append([InlineKeyboardButton("üë• –°–∫–≤–∞–¥—ã", callback_data="act:squads")])
        rows.append([InlineKeyboardButton("üóë –£–¥–∞–ª–∏—Ç—å –≤—Å–µ HWID", callback_data="act:hwid_all")])
        hwid_devices = last_user_data.get("hwid_devices") or []
        if current_section == "hwid" and hwid_devices:
            del_row = []
            for i in range(min(len(hwid_devices), 8)):
                del_row.append(InlineKeyboardButton(f"–£–¥. {i + 1}", callback_data=f"hwid_del:{i}"))
            if del_row:
                rows.append(del_row)
    return InlineKeyboardMarkup(rows)


def _get_message_content(update: Update) -> Optional[tuple]:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç (type, payload) –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏—è: ('text', str) –∏–ª–∏ ('photo', file_id, caption) –∏ —Ç.–¥."""
    if not update.message:
        return None
    msg = update.message
    if msg.text:
        return ("text", (msg.text or "").strip())
    if msg.caption:
        return ("caption_only", (msg.caption or "").strip())
    if msg.photo:
        return ("photo", msg.photo[-1].file_id, (msg.caption or "").strip())
    if msg.document:
        return ("document", msg.document.file_id, (msg.caption or "").strip())
    if msg.video:
        return ("video", msg.video.file_id, (msg.caption or "").strip())
    if msg.voice:
        return ("voice", msg.voice.file_id, "")
    if msg.audio:
        return ("audio", msg.audio.file_id, (msg.caption or "").strip())
    return None


async def _send_content_to_topic(
    context: ContextTypes.DEFAULT_TYPE,
    chat_id: int,
    message_thread_id: int,
    content: tuple,
    prefix: str = "",
) -> bool:
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∫–æ–Ω—Ç–µ–Ω—Ç (—Ä–µ–∑—É–ª—å—Ç–∞—Ç _get_message_content) –≤ —Ç–æ–ø–∏–∫. prefix ‚Äî –ø–æ–¥–ø–∏—Å—å –ø–µ—Ä–µ–¥ —Ç–µ–∫—Å—Ç–æ–º."""
    try:
        kind = content[0]
        if kind == "text":
            text = content[1]
            body = f"{prefix}\n\n{text}" if prefix else text
            await context.bot.send_message(
                chat_id=chat_id,
                message_thread_id=message_thread_id,
                text=body,
                parse_mode="HTML" if prefix else None,
            )
        elif kind == "caption_only":
            text = content[1]
            body = f"{prefix}\n\n{text}" if prefix else text
            await context.bot.send_message(
                chat_id=chat_id,
                message_thread_id=message_thread_id,
                text=body,
                parse_mode="HTML" if prefix else None,
            )
        elif kind == "photo":
            file_id, caption = content[1], content[2]
            cap = f"{prefix}\n\n{caption}" if (prefix or caption) else (prefix or caption or None)
            await context.bot.send_photo(
                chat_id=chat_id,
                message_thread_id=message_thread_id,
                photo=file_id,
                caption=cap,
                parse_mode="HTML" if cap else None,
            )
        elif kind == "document":
            file_id, caption = content[1], content[2]
            cap = f"{prefix}\n\n{caption}" if (prefix or caption) else (prefix or caption or None)
            await context.bot.send_document(
                chat_id=chat_id,
                message_thread_id=message_thread_id,
                document=file_id,
                caption=cap,
                parse_mode="HTML" if cap else None,
            )
        elif kind == "video":
            file_id, caption = content[1], content[2]
            cap = f"{prefix}\n\n{caption}" if (prefix or caption) else (prefix or caption or None)
            await context.bot.send_video(
                chat_id=chat_id,
                message_thread_id=message_thread_id,
                video=file_id,
                caption=cap,
                parse_mode="HTML" if cap else None,
            )
        elif kind == "voice":
            await context.bot.send_voice(
                chat_id=chat_id,
                message_thread_id=message_thread_id,
                voice=content[1],
                caption=prefix or None,
                parse_mode="HTML" if prefix else None,
            )
        elif kind == "audio":
            await context.bot.send_audio(
                chat_id=chat_id,
                message_thread_id=message_thread_id,
                audio=content[1],
                caption=prefix or content[2] or None,
                parse_mode="HTML" if prefix else None,
            )
        else:
            return False
        return True
    except Exception as e:
        logger.warning("_send_content_to_topic: %s", e)
        return False


async def _forward_content_to_client(
    context: ContextTypes.DEFAULT_TYPE,
    client_id: int,
    content: tuple,
    manager_name: str,
) -> bool:
    """–ü–µ—Ä–µ—Å—ã–ª–∞–µ—Ç –∫–æ–Ω—Ç–µ–Ω—Ç –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –∫–ª–∏–µ–Ω—Ç—É —Å –ø–æ–¥–ø–∏—Å—å—é ¬´–ü–æ–¥–¥–µ—Ä–∂–∫–∞ (–∏–º—è)¬ª."""
    prefix = f"üí¨ <b>–ü–æ–¥–¥–µ—Ä–∂–∫–∞</b> ({manager_name})"
    try:
        kind = content[0]
        if kind == "text":
            text = content[1]
            await context.bot.send_message(
                chat_id=client_id,
                text=f"{prefix}:\n\n{text}",
                parse_mode="HTML",
            )
        elif kind == "caption_only":
            text = content[1]
            await context.bot.send_message(
                chat_id=client_id,
                text=f"{prefix}:\n\n{text}",
                parse_mode="HTML",
            )
        elif kind == "photo":
            file_id, caption = content[1], content[2]
            cap = f"{prefix}\n\n{caption}" if caption else prefix
            await context.bot.send_photo(
                chat_id=client_id,
                photo=file_id,
                caption=cap,
                parse_mode="HTML",
            )
        elif kind == "document":
            file_id, caption = content[1], content[2]
            cap = f"{prefix}\n\n{caption}" if caption else prefix
            await context.bot.send_document(
                chat_id=client_id,
                document=file_id,
                caption=cap,
                parse_mode="HTML",
            )
        elif kind == "video":
            file_id, caption = content[1], content[2]
            cap = f"{prefix}\n\n{caption}" if caption else prefix
            await context.bot.send_video(
                chat_id=client_id,
                video=file_id,
                caption=cap,
                parse_mode="HTML",
            )
        elif kind == "voice":
            await context.bot.send_voice(
                chat_id=client_id,
                voice=content[1],
                caption=prefix,
                parse_mode="HTML",
            )
        elif kind == "audio":
            await context.bot.send_audio(
                chat_id=client_id,
                audio=content[1],
                caption=prefix or content[2] or None,
                parse_mode="HTML",
            )
        else:
            return False
        return True
    except Exception as e:
        logger.warning("_forward_content_to_client: %s", e)
        return False


def build_support_keyboard(
    client_id: int,
    current_section: str,
    last_user_data: Dict[str, Any],
    ai_stopped: bool = False,
    support_blocked: bool = False,
) -> InlineKeyboardMarkup:
    """–ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è —Å–æ–æ–±—â–µ–Ω–∏—è –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É: —Å–µ–∫—Ü–∏–∏ + –¥–µ–π—Å—Ç–≤–∏—è + –±–ª–æ–∫ –≤ –¢–ü + –ò–ò + –ó–∞–≤–µ—Ä—à–∏—Ç—å —Ç–∏–∫–µ—Ç."""
    labels = [
        ("üë§ –ü—Ä–æ—Ñ–∏–ª—å", "profile"),
        ("üìä –¢—Ä–∞—Ñ–∏–∫", "traffic"),
        ("üìÖ –î–∞—Ç—ã", "dates"),
        ("üîó –ü–æ–¥–ø–∏—Å–∫–∞", "subscription"),
        ("üì± –£—Å—Ç—Ä–æ–π—Å—Ç–≤–∞", "hwid"),
    ]
    row1, row2 = [], []
    for i, (label, section) in enumerate(labels):
        text = f"‚úì {label}" if section == current_section else label
        btn = InlineKeyboardButton(text=text, callback_data=f"sup:{client_id}:{section}")
        if i < 3:
            row1.append(btn)
        else:
            row2.append(btn)
    rows = [row1, row2]
    # –ö–Ω–æ–ø–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ–≥–¥–∞ (–ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ API –ø–æ –Ω–∞–∂–∞—Ç–∏—é –±—É–¥–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ)
    user = (last_user_data or {}).get("user") or {}
    sub = (last_user_data or {}).get("subscription")
    block_btn = (
        InlineKeyboardButton("üîì –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å", callback_data=f"sup_act:{client_id}:enable")
        if user and _is_user_disabled(user, sub)
        else InlineKeyboardButton("üîí –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å", callback_data=f"sup_act:{client_id}:disable")
    )
    rows.append([
        InlineKeyboardButton("üîÑ –°–±—Ä–æ—Å —Ç—Ä–∞—Ñ–∏–∫–∞", callback_data=f"sup_act:{client_id}:reset_traffic"),
        InlineKeyboardButton("üîó –ü–µ—Ä–µ–≤—ã–ø—É—Å–∫", callback_data=f"sup_act:{client_id}:revoke_sub"),
    ])
    rows.append([block_btn, InlineKeyboardButton("üí∞ –í—ã—Å—Ç–∞–≤–∏—Ç—å —Å—á—ë—Ç", callback_data=f"sup_act:{client_id}:invoice")])
    if (last_user_data or {}).get("bedolaga_user"):
        rows.append([InlineKeyboardButton("üìú –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ (Bedolaga)", callback_data=f"sup_act:{client_id}:bedolaga_tx")])
    rows.append([InlineKeyboardButton("üë• –°–∫–≤–∞–¥—ã", callback_data=f"sup_act:{client_id}:squads")])
    rows.append([InlineKeyboardButton("üóë –£–¥–∞–ª–∏—Ç—å –≤—Å–µ HWID", callback_data=f"sup_act:{client_id}:hwid_all")])
    hwid_devices = (last_user_data or {}).get("hwid_devices") or []
    if current_section == "hwid" and hwid_devices:
        del_row = [InlineKeyboardButton(f"–£–¥. {i + 1}", callback_data=f"sup_hwid:{client_id}:{i}") for i in range(min(len(hwid_devices), 8))]
        if del_row:
            rows.append(del_row)
    # –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –≤ –¢–ü / –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –≤ –¢–ü (–∫–ª–∏–µ–Ω—Ç –Ω–µ —Å–º–æ–∂–µ—Ç –ø–∏—Å–∞—Ç—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É)
    if support_blocked:
        rows.append([InlineKeyboardButton("‚úÖ –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –≤ –¢–ü", callback_data=f"sup_act:{client_id}:unblock_support")])
    else:
        rows.append([InlineKeyboardButton("üö´ –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –≤ –¢–ü", callback_data=f"sup_act:{client_id}:block_support")])
    # –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ò–ò / –í–∫–ª—é—á–∏—Ç—å –ò–ò ‚Äî –ø–µ—Ä–µ–π—Ç–∏ –≤ —á–∞—Ç —Å–∞–º–æ–º—É
    if ai_stopped:
        rows.append([InlineKeyboardButton("‚ñ∂Ô∏è –í–∫–ª—é—á–∏—Ç—å –ò–ò", callback_data=f"sup_act:{client_id}:start_ai")])
    else:
        rows.append([InlineKeyboardButton("üõë –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ò–ò ¬∑ –ø–µ—Ä–µ–π—Ç–∏ –≤ —á–∞—Ç", callback_data=f"sup_act:{client_id}:stop_ai")])
    rows.append([InlineKeyboardButton("‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å —Ç–∏–∫–µ—Ç", callback_data=f"close_ticket:{client_id}")])
    return InlineKeyboardMarkup(rows)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
    user_id = update.effective_user.id

    # –ö–ª–∏–µ–Ω—Ç (–Ω–µ –º–µ–Ω–µ–¥–∂–µ—Ä) ‚Äî –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏, –∫–Ω–æ–ø–∫—É Mini App –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º
    if not check_access(user_id):
        try:
            await context.bot.set_chat_menu_button(
                chat_id=update.effective_chat.id,
                menu_button=MenuButtonCommands(),
            )
        except Exception as e:
            logger.debug("set_chat_menu_button commands: %s", e)
        await update.message.reply_text(
            f"üëã –ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ! –≠—Ç–æ –ø–æ–¥–¥–µ—Ä–∂–∫–∞ {SERVICE_NAME}.\n\n"
            "–ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ ‚Äî –º–µ–Ω–µ–¥–∂–µ—Ä –æ—Ç–≤–µ—Ç–∏—Ç –∑–¥–µ—Å—å –≤ –±–æ—Ç–µ."
        )
        return

    text = (
        f"üëã <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ {SERVICE_NAME}!</b>\n\n"
        "üìù <b>–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:</b>\n"
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ Telegram ID –∏–ª–∏ username –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∏ —è –ø—Ä–∏—à–ª—é –≤—Å—é –¥–æ—Å—Ç—É–ø–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –Ω–µ–º –∏ –µ–≥–æ –ø–æ–¥–ø–∏—Å–∫–µ.\n\n"
        "üí° <b>–ü—Ä–∏–º–µ—Ä—ã:</b>\n"
        "‚Ä¢ <code>123456789</code> (Telegram ID)\n"
        "‚Ä¢ <code>@username</code> –∏–ª–∏ <code>username</code> (username)\n\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /help –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏."
    )
    reply_markup = None
    if MINI_APP_URL:
        reply_markup = InlineKeyboardMarkup([[
            InlineKeyboardButton("üì± –û—Ç–∫—Ä—ã—Ç—å –º–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ", web_app=WebAppInfo(url=MINI_APP_URL))
        ]])
    await update.message.reply_text(text, parse_mode='HTML', reply_markup=reply_markup)
    if MINI_APP_URL:
        try:
            await context.bot.set_chat_menu_button(
                chat_id=update.effective_chat.id,
                menu_button=MenuButtonWebApp(text="üì± –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ", web_app=WebAppInfo(url=MINI_APP_URL)),
            )
        except Exception as e:
            logger.debug("set_chat_menu_button: %s", e)


async def _refresh_last_user_data(context: ContextTypes.DEFAULT_TYPE) -> Optional[Dict[str, Any]]:
    """–û–±–Ω–æ–≤–ª—è–µ—Ç last_user_data –∏–∑ API –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –µ–≥–æ."""
    last = context.user_data.get("last_user_data")
    if not last or not last.get("user", {}).get("uuid"):
        return None
    user_uuid = last["user"]["uuid"]
    user = get_user_by_telegram_id(str(last["user"].get("telegramId") or "")) or get_user_by_username(last["user"].get("username") or "")
    if not user:
        return last
    subscription = get_subscription_by_uuid(user_uuid)
    hwid_devices = get_hwid_devices(user_uuid) or []
    telegram_id_b = user.get("telegramId") or None
    bedolaga_user = get_bedolaga_user(str(telegram_id_b)) if telegram_id_b and _bedolaga_configured() else last.get("bedolaga_user")
    new_last = {"user": user, "subscription": subscription, "hwid_devices": hwid_devices, "bedolaga_user": bedolaga_user}
    context.user_data["last_user_data"] = new_last
    return new_last


async def action_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫ –¥–µ–π—Å—Ç–≤–∏–π: —Å–±—Ä–æ—Å —Ç—Ä–∞—Ñ–∏–∫–∞, –ø–µ—Ä–µ–≤—ã–ø—É—Å–∫ –ø–æ–¥–ø–∏—Å–∫–∏, —É–¥–∞–ª–µ–Ω–∏–µ HWID."""
    query = update.callback_query
    user_id = update.effective_user.id
    if not check_access(user_id):
        await query.answer("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.", show_alert=True)
        return
    data = query.data
    last = context.user_data.get("last_user_data")
    if not last or not last.get("user", {}).get("uuid"):
        await query.answer("–î–∞–Ω–Ω—ã–µ —É—Å—Ç–∞—Ä–µ–ª–∏. –í—ã–ø–æ–ª–Ω–∏—Ç–µ –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫.", show_alert=True)
        return
    user_uuid = last["user"]["uuid"]
    subscription = last.get("subscription")
    hwid_devices = last.get("hwid_devices") or []
    ok, action_msg = False, ""

    if data == "act:reset_traffic":
        await query.answer("–°–±—Ä–æ—Å —Ç—Ä–∞—Ñ–∏–∫–∞...")
        ok, action_msg = api_reset_user_traffic(user_uuid)
    elif data == "act:revoke_sub":
        await query.answer("–ü–µ—Ä–µ–≤—ã–ø—É—Å–∫ –ø–æ–¥–ø–∏—Å–∫–∏...")
        ok, action_msg = api_revoke_user_subscription(user_uuid)
    elif data == "act:disable":
        await query.answer("–ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è...")
        ok, action_msg = api_disable_user(user_uuid)
    elif data == "act:enable":
        await query.answer("–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è...")
        ok, action_msg = api_enable_user(user_uuid)
    elif data == "act:invoice":
        await query.answer()
        user = last.get("user", {})
        client_id = user.get("telegramId")
        if isinstance(client_id, str) and client_id.isdigit():
            client_id = int(client_id)
        elif not isinstance(client_id, int):
            client_id = None
        manager_id = update.effective_user.id
        payload = {
            "client_id": client_id,
            "manager_id": manager_id,
            "user_uuid": user.get("uuid"),
        }
        context.user_data["awaiting_invoice"] = payload
        _set_awaiting_invoice_by_manager(context, manager_id, payload)
        try:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="üí∞ <b>–í—ã—Å—Ç–∞–≤–∏—Ç—å —Å—á—ë—Ç</b>\n\n–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –≤ —Ä—É–±–ª—è—Ö (—á–∏—Å–ª–æ):",
                parse_mode="HTML",
            )
        except Exception as e:
            logger.warning("send invoice prompt to manager: %s", e)
        return
    elif data == "act:bedolaga_tx":
        await query.answer("–ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π...")
        bedolaga_user = last.get("bedolaga_user")
        if not bedolaga_user:
            try:
                await context.bot.send_message(
                    chat_id=update.effective_chat.id,
                    text="–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö Bedolaga –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.",
                    parse_mode="HTML",
                )
            except Exception as e:
                logger.warning("send bedolaga_tx error: %s", e)
            return
        bedolaga_id = bedolaga_user.get("id")
        if not bedolaga_id:
            try:
                await context.bot.send_message(
                    chat_id=update.effective_chat.id,
                    text="–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å id –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ Bedolaga.",
                    parse_mode="HTML",
                )
            except Exception as e:
                logger.warning("send bedolaga_tx error: %s", e)
            return
        transactions = get_bedolaga_transactions(int(bedolaga_id), limit=30)
        text = _format_bedolaga_transactions_message(transactions)
        try:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=text,
                parse_mode="HTML",
            )
        except Exception as e:
            logger.warning("send bedolaga transactions: %s", e)
        return
    elif data == "act:squads":
        await query.answer()
        context.user_data["squads_target_uuid"] = user_uuid
        internal = get_internal_squads() or []
        external = get_external_squads() or []
        rows = []
        for s in internal:
            name = (s.get("name") or s.get("uuid", ""))[:32]
            rows.append([InlineKeyboardButton(f"üìÅ {name}", callback_data=f"squad:i:{s.get('uuid', '')}")])
        for s in external:
            name = (s.get("name") or s.get("uuid", ""))[:32]
            rows.append([InlineKeyboardButton(f"üåê {name}", callback_data=f"squad:e:{s.get('uuid', '')}")])
        if not rows:
            try:
                await query.edit_message_text(
                    (query.message.text or "") + "\n\nüë• <b>–°–∫–≤–∞–¥—ã</b>\n\n–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–∫–≤–∞–¥–æ–≤.",
                    parse_mode="HTML",
                )
            except Exception:
                await context.bot.send_message(
                    chat_id=update.effective_chat.id,
                    text="üë• –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–∫–≤–∞–¥–æ–≤.",
                )
            return
        rows.append([InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="squad_back")])
        text = "üë• <b>–í—ã–±–µ—Ä–∏—Ç–µ —Å–∫–≤–∞–¥ –¥–ª—è –≤—ã–¥–∞—á–∏ –∫–ª–∏–µ–Ω—Ç—É:</b>"
        try:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=text,
                parse_mode="HTML",
                reply_markup=InlineKeyboardMarkup(rows),
            )
        except Exception as e:
            logger.warning("send squads list: %s", e)
        return
    elif data == "act:hwid_all":
        await query.answer("–£–¥–∞–ª–µ–Ω–∏–µ –≤—Å–µ—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤...")
        ok, action_msg = api_delete_all_hwid(user_uuid)
    elif data.startswith("hwid_del:"):
        try:
            idx = int(data.split(":")[1])
        except (IndexError, ValueError):
            await query.answer("–û—à–∏–±–∫–∞", show_alert=True)
            return
        if idx < 0 or idx >= len(hwid_devices):
            await query.answer("–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", show_alert=True)
            return
        hwid = hwid_devices[idx].get("hwid")
        if not hwid:
            await query.answer("–û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö.", show_alert=True)
            return
        await query.answer("–£–¥–∞–ª–µ–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞...")
        ok, action_msg = api_delete_hwid_device(user_uuid, hwid)
    else:
        return

    last = await _refresh_last_user_data(context)
    if not last:
        last = context.user_data.get("last_user_data")
    user = last["user"]
    subscription = last.get("subscription")
    hwid_devices = last.get("hwid_devices") or []
    username_display = user.get("username", "N/A")
    header = f"‚úÖ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å</b> @{username_display}\n\n"
    if action_msg:
        header = header + (f"‚úÖ <i>{action_msg}</i>\n\n" if ok else f"‚ùå <i>{action_msg}</i>\n\n")
    if last.get("bedolaga_user"):
        header += f"üí∞ <b>–ë–∞–ª–∞–Ω—Å (Bedolaga):</b> {_format_bedolaga_balance(last['bedolaga_user'])} ‚ÇΩ\n\n"
    section = (
        "hwid" if data.startswith("hwid_del") or data == "act:hwid_all"
        else ("traffic" if data == "act:reset_traffic"
              else ("profile" if data in ("act:disable", "act:enable") else "subscription"))
    )
    section_text = get_section_text(section, user, subscription, hwid_devices)
    full_text = header + section_text
    keyboard = build_section_keyboard(section, last)
    try:
        await query.edit_message_text(full_text, parse_mode="HTML", reply_markup=keyboard)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")


async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∂–∞—Ç–∏–π –∫–Ω–æ–ø–æ–∫ —Å–µ–∫—Ü–∏–π."""
    query = update.callback_query
    await query.answer()
    user_id = update.effective_user.id
    if not check_access(user_id):
        await query.edit_message_text("‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return
    data = query.data
    if not data.startswith("s:"):
        return
    section = data[2:]
    if section not in SECTIONS:
        return
    last = context.user_data.get("last_user_data")
    if not last:
        await query.edit_message_text("‚è≥ –î–∞–Ω–Ω—ã–µ —É—Å—Ç–∞—Ä–µ–ª–∏. –í—ã–ø–æ–ª–Ω–∏—Ç–µ –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫ –ø–æ ID –∏–ª–∏ username.")
        return
    user = last["user"]
    subscription = last.get("subscription")
    hwid_devices = last.get("hwid_devices")
    username_display = user.get("username", "N/A")
    header = f"‚úÖ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å</b> @{username_display}\n\n"
    if last.get("bedolaga_user"):
        header += f"üí∞ <b>–ë–∞–ª–∞–Ω—Å (Bedolaga):</b> {_format_bedolaga_balance(last['bedolaga_user'])} ‚ÇΩ\n\n"
    section_text = get_section_text(section, user, subscription, hwid_devices)
    full_text = header + section_text
    keyboard = build_section_keyboard(section, last)
    try:
        await query.edit_message_text(
            full_text,
            parse_mode="HTML",
            reply_markup=keyboard,
        )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")


async def handle_client_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–ª–∏–µ–Ω—Ç –Ω–∞–ø–∏—Å–∞–ª –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É: 1) –∫–∞—Ä—Ç–æ—á–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è, 2) –≤—Ç–æ—Ä—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º ‚Äî —Ç–µ–∫—Å—Ç/—Ñ–æ—Ç–æ/—Ñ–∞–π–ª."""
    client_id = update.effective_user.id
    # –ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –≤ –¢–ü ‚Äî –Ω–µ –ø—Ä–∏–Ω–∏–º–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è
    blocked = context.application.bot_data.get("support_blocked_clients")
    if isinstance(blocked, set) and client_id in blocked:
        await update.message.reply_text("–í—ã –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –≤ –ø–æ–¥–¥–µ—Ä–∂–∫–µ. –ü–∏—Å–∞—Ç—å —Å—é–¥–∞ –±–æ–ª—å—à–µ –Ω–µ–ª—å–∑—è.")
        return
    client_username = update.effective_user.username or ""
    client_name = (update.effective_user.first_name or "") + (" " + (update.effective_user.last_name or "")).strip()
    content = _get_message_content(update)
    if not content:
        await update.message.reply_text("–ù–∞–ø–∏—à–∏—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ/—Ñ–∞–π–ª.")
        return
    # –£ –∫–ª–∏–µ–Ω—Ç–æ–≤ –∫–Ω–æ–ø–∫–∞ Mini App –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è ‚Äî —Å—Ç–∞–≤–∏–º –∫–Ω–æ–ø–∫—É ¬´–ö–æ–º–∞–Ω–¥—ã¬ª
    try:
        await context.bot.set_chat_menu_button(
            chat_id=update.effective_chat.id,
            menu_button=MenuButtonCommands(),
        )
    except Exception as e:
        logger.debug("set_chat_menu_button commands: %s", e)

    api_user = get_user_by_telegram_id(str(client_id))
    user_uuid = api_user.get("uuid") if api_user else None
    subscription = get_subscription_by_uuid(user_uuid) if user_uuid else None
    hwid_devices = get_hwid_devices(user_uuid) if user_uuid else []
    bedolaga_user = get_bedolaga_user(str(client_id)) if _bedolaga_configured() else None

    # –¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∫–ª–∏–µ–Ω—Ç–∞ –¥–ª—è –ò–ò (–∏ –¥–ª—è –∏—Å—Ç–æ—Ä–∏–∏)
    if content[0] in ("text", "caption_only"):
        user_text_for_ai = (content[1] or "").strip()
    elif content[0] == "voice" and _AI_SUPPORT_AVAILABLE and transcribe_voice_groq:
        user_text_for_ai = (transcribe_voice_groq(context.bot, content[1]) or "").strip() or "[–ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ]"
    elif content[0] == "voice":
        user_text_for_ai = "[–ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ]"
    elif content[0] == "photo":
        user_text_for_ai = "–ö–ª–∏–µ–Ω—Ç –æ—Ç–ø—Ä–∞–≤–∏–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ." + (" " + (content[2] or "").strip() if len(content) > 2 and (content[2] or "").strip() else "")
    else:
        user_text_for_ai = "–ö–ª–∏–µ–Ω—Ç –æ—Ç–ø—Ä–∞–≤–∏–ª –≤–ª–æ–∂–µ–Ω–∏–µ (—Ñ–∞–π–ª/–≤–∏–¥–µ–æ)." + (" " + (content[2] or "").strip() if len(content) > 2 and (content[2] or "").strip() else "")

    # –î–ª—è —Ñ–æ—Ç–æ –ø—Ä–∏ Groq ‚Äî —Å–∫–∞—á–∏–≤–∞–µ–º –∏ –ø–µ—Ä–µ–¥–∞—ë–º –≤ vision
    image_base64_arg = None
    image_mime_arg = None
    if content[0] == "photo" and _AI_SUPPORT_AVAILABLE and AI_PROVIDER == "groq" and is_ai_enabled():
        try:
            tg_file = await context.bot.get_file(content[1])
            fd, path = tempfile.mkstemp(suffix=".jpg")
            os.close(fd)
            await tg_file.download_to_drive(path)
            with open(path, "rb") as f:
                data = f.read()
            os.unlink(path)
            if len(data) <= 4 * 1024 * 1024:
                image_base64_arg = base64.b64encode(data).decode("utf-8")
                image_mime_arg = "image/jpeg"
        except Exception as e:
            logger.warning("Support: failed to download photo for vision: %s", e)

    ai_reply = None
    # –ï—Å–ª–∏ –∫–ª–∏–µ–Ω—Ç —É–∂–µ –Ω–∞–∂–∞–ª ¬´–ü–æ–∑–≤–∞—Ç—å –º–µ–Ω–µ–¥–∂–µ—Ä–∞¬ª ‚Äî –ò–ò –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç, —Ç–æ–ª—å–∫–æ –º–µ–Ω–µ–¥–∂–µ—Ä
    client_wants_manager = (context.application.bot_data.get("support_client_wants_manager") or set())
    if client_id in client_wants_manager:
        pass  # ai_reply –æ—Å—Ç–∞—ë—Ç—Å—è None
    elif _AI_SUPPORT_AVAILABLE and is_ai_enabled() and (user_text_for_ai or image_base64_arg) and build_client_context_for_ai and get_system_prompt and get_ai_reply:
        try:
            tariffs_configs = get_subscription_page_configs() or []
            tariff_names = [str(c.get("name") or "").strip() for c in tariffs_configs if c.get("name")]
            tariffs_text = f"–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–∞—Ä–∏—Ñ—ã –≤ –±–æ—Ç–µ: {', '.join(tariff_names)}" if tariff_names else None
            client_context = build_client_context_for_ai(
                api_user, subscription, hwid_devices, bedolaga_user, SERVICE_NAME, tariffs_text=tariffs_text
            )
            history = get_conversation_history(context.application.bot_data, client_id)
            prompt_text = (content[2] or "").strip() if content[0] == "photo" and len(content) > 2 else user_text_for_ai
            ai_reply = get_ai_reply(
                get_system_prompt(SERVICE_NAME),
                client_context,
                history,
                prompt_text or user_text_for_ai,
                SERVICE_NAME,
                bot_data=context.application.bot_data,
                image_base64=image_base64_arg,
                image_mime=image_mime_arg,
            )
            add_to_conversation_history(context.application.bot_data, client_id, "user", user_text_for_ai)
            if ai_reply:
                add_to_conversation_history(context.application.bot_data, client_id, "assistant", ai_reply)
                if add_global_example:
                    add_global_example(context.application.bot_data, user_text_for_ai, ai_reply)
            elif user_text_for_ai or image_base64_arg:
                logger.warning("AI support: get_ai_reply returned None for client %s. Check GROQ_API_KEY and API limits.", client_id)
        except Exception as e:
            logger.exception("AI support error for client %s: %s", client_id, e)
    elif user_text_for_ai and (not _AI_SUPPORT_AVAILABLE or not is_ai_enabled()):
        if not _AI_SUPPORT_AVAILABLE:
            logger.debug("AI support: module not loaded (ai_support import failed)")
        elif not is_ai_enabled():
            logger.debug("AI support: GROQ_API_KEY not set or empty (add to .env and restart)")

    # –ó–∞–≥–æ–ª–æ–≤–æ–∫ –∫–∞—Ä—Ç–æ—á–∫–∏ –±–µ–∑ —Ç–µ–∫—Å—Ç–∞ —Å–æ–æ–±—â–µ–Ω–∏—è ‚Äî —Ç–µ–∫—Å—Ç/—Ñ–æ—Ç–æ –∏–¥—É—Ç –≤—Ç–æ—Ä—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º
    support_header = (
        f"üì© <b>–°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞</b>\n"
        f"Telegram ID: <code>{client_id}</code>\n"
        f"–ò–º—è: {client_name or '‚Äî'}\n"
        f"Username: @{client_username or '‚Äî'}\n\n"
    )
    if bedolaga_user:
        balance_str = _format_bedolaga_balance(bedolaga_user)
        support_header += f"üí∞ <b>–ë–∞–ª–∞–Ω—Å (Bedolaga):</b> {balance_str} ‚ÇΩ\n\n"
    if api_user or subscription:
        support_header += f"üìã <b>–î–∞–Ω–Ω—ã–µ –∏–∑ API {SERVICE_NAME}:</b>\n"
        if api_user:
            support_header += f"üÜî UUID: <code>{api_user.get('uuid', 'N/A')}</code>\n"
            sub_user = (subscription or {}).get("user", {}) if subscription else {}
            status = sub_user.get("userStatus") or api_user.get("status", "N/A")
            uname = api_user.get("username") or "‚Äî"
            support_header += f"üë§ @{uname} ¬∑ {status}\n"
            support_header += f"üìÖ –ò—Å—Ç–µ–∫–∞–µ—Ç: {format_datetime(api_user.get('expireAt'))}\n"
            ut = api_user.get("userTraffic") or {}
            used = ut.get("usedTrafficBytes", 0)
            limit = api_user.get("trafficLimitBytes", 0)
            limit_str = format_bytes(limit) if limit > 0 else "‚àû"
            support_header += f"üìä –¢—Ä–∞—Ñ–∏–∫: {format_bytes(used)} / {limit_str}\n"
        support_header += "\n"
    if "support_clients" not in context.application.bot_data:
        context.application.bot_data["support_clients"] = {}
    if "support_has_card" not in context.application.bot_data:
        context.application.bot_data["support_has_card"] = set()
    if "support_topic_by_client" not in context.application.bot_data:
        context.application.bot_data["support_topic_by_client"] = {}
    if "support_thread_to_client" not in context.application.bot_data:
        context.application.bot_data["support_thread_to_client"] = {}
    if "support_ticket_counter" not in context.application.bot_data:
        context.application.bot_data["support_ticket_counter"] = 0
    context.application.bot_data["support_clients"][client_id] = {
        "user": api_user or {},
        "subscription": subscription,
        "hwid_devices": hwid_devices,
        "support_header": support_header,
        "bedolaga_user": bedolaga_user,
    }

    last_data = {"user": api_user or {}, "subscription": subscription, "hwid_devices": hwid_devices, "bedolaga_user": bedolaga_user}
    sent_ok = False
    topic_by_client = context.application.bot_data["support_topic_by_client"]
    thread_to_client = context.application.bot_data["support_thread_to_client"]

    # –û—Ç–≤–µ—Ç –ò–ò –∫–ª–∏–µ–Ω—Ç—É (–¥–æ —Å–æ–∑–¥–∞–Ω–∏—è/–æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ —Ç–æ–ø–∏–∫) + –∫–Ω–æ–ø–∫–∏ ¬´–ü–æ–∑–≤–∞—Ç—å –º–µ–Ω–µ–¥–∂–µ—Ä–∞¬ª –∏ ¬´–ó–∞–∫—Ä—ã—Ç—å —Ç–∏–∫–µ—Ç¬ª
    if ai_reply:
        try:
            client_buttons = InlineKeyboardMarkup([[
                InlineKeyboardButton("üë§ –ü–æ–∑–≤–∞—Ç—å –º–µ–Ω–µ–¥–∂–µ—Ä–∞", callback_data="call_manager"),
                InlineKeyboardButton("‚úÖ –ó–∞–∫—Ä—ã—Ç—å —Ç–∏–∫–µ—Ç", callback_data="client_close_ticket"),
            ]])
            await update.message.reply_text(
                f"üí¨ <b>–û—Ç–≤–µ—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏:</b>\n\n{ai_reply}",
                parse_mode="HTML",
                reply_markup=client_buttons,
            )
        except Exception as e:
            logger.warning("send AI reply to client: %s", e)

    if SUPPORT_GROUP_ID:
        # –õ–æ–≥–∏–∫–∞ —Å –≥—Ä—É–ø–ø–æ–π –ø–æ–¥–¥–µ—Ä–∂–∫–∏: –∫–∞–∂–¥—ã–π —Ç–∏–∫–µ—Ç ‚Äî —Ç–æ–ø–∏–∫ –≤ –≥—Ä—É–ø–ø–µ
        existing = topic_by_client.get(client_id)
        if existing:
            # –£–∂–µ –µ—Å—Ç—å —Ç–æ–ø–∏–∫ ‚Äî –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç –≤—Ç–æ—Ä—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º
            sent_ok = False
            try:
                sent_ok = await _send_content_to_topic(
                    context,
                    existing["chat_id"],
                    existing["message_thread_id"],
                    content,
                    prefix="üí¨ <b>–ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞</b>",
                )
                if sent_ok and ai_reply:
                    await context.bot.send_message(
                        chat_id=existing["chat_id"],
                        message_thread_id=existing["message_thread_id"],
                        text=f"ü§ñ <b>–û—Ç–≤–µ—Ç –ò–ò (–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∫–ª–∏–µ–Ω—Ç—É):</b>\n\n{ai_reply}",
                        parse_mode="HTML",
                    )
            except Exception as e:
                logger.warning("send to support topic: %s", e)
            if not sent_ok:
                topic_by_client.pop(client_id, None)
                thread_to_client.pop((existing["chat_id"], existing["message_thread_id"]), None)
        if not sent_ok and not existing:
            # –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π —Ç–æ–ø–∏–∫: "–¢–∏–∫–µ—Ç #N ‚Ä¢ –ò–º—è ‚Ä¢ ID{client_id}"
            context.application.bot_data["support_ticket_counter"] = (
                context.application.bot_data["support_ticket_counter"] + 1
            )
            ticket_num = context.application.bot_data["support_ticket_counter"]
            client_display = (client_name or "").strip() or (f"@{client_username}" if client_username else "‚Äî")
            topic_name = (f"‚ÅâÔ∏è –¢–∏–∫–µ—Ç #{ticket_num} ‚Ä¢ {client_display} ‚Ä¢ ID{client_id}")[:128]
            chat_ids_to_try = _support_chat_ids()
            last_error = None
            for group_chat_id in chat_ids_to_try:
                try:
                    logger.info("–°–æ–∑–¥–∞–Ω–∏–µ —Ç–æ–ø–∏–∫–∞ –≤ –≥—Ä—É–ø–ø–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ chat_id=%s, –Ω–∞–∑–≤–∞–Ω–∏–µ=%s", group_chat_id, topic_name)
                    forum_topic = await context.bot.create_forum_topic(
                        chat_id=group_chat_id,
                        name=topic_name,
                    )
                    thread_id = forum_topic.message_thread_id
                    username_display = (api_user or {}).get("username") or "‚Äî"
                    data_header = f"‚úÖ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å</b> @{username_display}\n\n"
                    section_text = get_section_text("profile", api_user or {}, subscription, hwid_devices)
                    full_text = support_header + data_header + section_text
                    ai_stopped = client_id in (context.application.bot_data.get("support_client_wants_manager") or set())
                    support_blocked = client_id in (context.application.bot_data.get("support_blocked_clients") or set())
                    keyboard = build_support_keyboard(client_id, "profile", last_data, ai_stopped=ai_stopped, support_blocked=support_blocked)
                    await context.bot.send_message(
                        chat_id=group_chat_id,
                        message_thread_id=thread_id,
                        text=full_text,
                        parse_mode="HTML",
                        reply_markup=keyboard,
                    )
                    # –í—Ç–æ—Ä—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º ‚Äî —Ç–µ–∫—Å—Ç/—Ñ–æ—Ç–æ/—Ñ–∞–π–ª –∫–ª–∏–µ–Ω—Ç–∞
                    await _send_content_to_topic(
                        context,
                        group_chat_id,
                        thread_id,
                        content,
                        prefix="üí¨ <b>–°–æ–æ–±—â–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞</b>",
                    )
                    if ai_reply:
                        try:
                            await context.bot.send_message(
                                chat_id=group_chat_id,
                                message_thread_id=thread_id,
                                text=f"ü§ñ <b>–û—Ç–≤–µ—Ç –ò–ò (–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –∫–ª–∏–µ–Ω—Ç—É):</b>\n\n{ai_reply}",
                                parse_mode="HTML",
                            )
                        except Exception as e:
                            logger.warning("send AI reply to topic: %s", e)
                    topic_by_client[client_id] = {
                        "chat_id": group_chat_id,
                        "message_thread_id": thread_id,
                        "topic_name": topic_name,
                    }
                    thread_to_client[(group_chat_id, thread_id)] = client_id
                    context.application.bot_data["support_has_card"].add(client_id)
                    sent_ok = True
                    logger.info("–¢–æ–ø–∏–∫ —Å–æ–∑–¥–∞–Ω: chat_id=%s, thread_id=%s", group_chat_id, thread_id)
                    break
                except Exception as e:
                    last_error = e
                    logger.warning("create_forum_topic chat_id=%s: %s", group_chat_id, e)
            if not sent_ok and last_error:
                logger.exception("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Ç–æ–ø–∏–∫ –ø–æ–¥–¥–µ—Ä–∂–∫–∏: %s", last_error)
                err_str = str(last_error).lower()
                if "manage" in err_str or "topic" in err_str or "right" in err_str or "admin" in err_str:
                    logger.warning(
                        "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ: –±–æ—Ç ‚Äî –∞–¥–º–∏–Ω –≥—Ä—É–ø–ø—ã —Å –ø—Ä–∞–≤–æ–º ¬´–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç–æ–ø–∏–∫–∞–º–∏¬ª; –≤ –≥—Ä—É–ø–ø–µ –≤–∫–ª—é—á–µ–Ω—ã —Ç–æ–ø–∏–∫–∏ (—Ä–µ–∂–∏–º —Ñ–æ—Ä—É–º–∞)."
                    )
                if "chat not found" in err_str or "400" in err_str:
                    logger.warning(
                        "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ SUPPORT_GROUP_ID: –¥–ª—è —Å—É–ø–µ—Ä–≥—Ä—É–ø–ø—ã –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–æ–ª–Ω—ã–π id –≤–∏–¥–∞ -100xxxxxxxxxx (–º–æ–∂–Ω–æ –≤–∑—è—Ç—å –∏–∑ –ª–æ–≥–æ–≤ –ø—Ä–∏ —Å–æ–æ–±—â–µ–Ω–∏–∏ –≤ –≥—Ä—É–ø–ø—É)."
                    )
    if not sent_ok:
        # –ù–µ—Ç SUPPORT_GROUP_ID –∏–ª–∏ –æ—à–∏–±–∫–∞ ‚Äî fallback: –æ—Ç–ø—Ä–∞–≤–∫–∞ –∫–∞–∂–¥–æ–º—É –º–µ–Ω–µ–¥–∂–µ—Ä—É –≤ –ª–∏—á–∫—É
        has_card = client_id in context.application.bot_data["support_has_card"]
        content_line = (
            f"üí¨ <b>–¢–µ–∫—Å—Ç:</b>\n{content[1]}\n\n"
            if content[0] == "text"
            else "üí¨ <b>–í–ª–æ–∂–µ–Ω–∏–µ:</b> —Ñ–æ—Ç–æ/—Ñ–∞–π–ª\n\n"
        )
        support_header_fallback = support_header + content_line
        if not has_card:
            username_display = (api_user or {}).get("username") or "‚Äî"
            data_header = f"‚úÖ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å</b> @{username_display}\n\n"
            section_text = get_section_text("profile", api_user or {}, subscription, hwid_devices)
            full_text = support_header_fallback + data_header + section_text
            ai_stopped = client_id in (context.application.bot_data.get("support_client_wants_manager") or set())
            support_blocked = client_id in (context.application.bot_data.get("support_blocked_clients") or set())
            keyboard = build_support_keyboard(client_id, "profile", last_data, ai_stopped=ai_stopped, support_blocked=support_blocked)
            context.application.bot_data["support_has_card"].add(client_id)
            for manager_id in ALLOWED_MANAGER_IDS:
                try:
                    await context.bot.send_message(
                        chat_id=manager_id,
                        text=full_text,
                        parse_mode="HTML",
                        reply_markup=keyboard,
                    )
                    sent_ok = True
                except Exception as e:
                    logger.warning("send to manager %s: %s", manager_id, e)
        else:
            preview = (content[1][:200] + "‚Ä¶") if content[0] == "text" and len(content[1]) > 200 else (content[1] if content[0] == "text" else "—Ñ–æ—Ç–æ/—Ñ–∞–π–ª")
            short_text = (
                f"üì© <b>–ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞</b>\n"
                f"ID: <code>{client_id}</code> ¬∑ @{client_username or '‚Äî'}\n\n"
                f"üí¨ <b>–¢–µ–∫—Å—Ç:</b>\n{preview}"
            )
            keyboard = InlineKeyboardMarkup([[
                InlineKeyboardButton("‚úÖ –ó–∞–≤–µ—Ä—à–∏—Ç—å —Ç–∏–∫–µ—Ç", callback_data=f"close_ticket:{client_id}"),
            ]])
            for manager_id in ALLOWED_MANAGER_IDS:
                try:
                    await context.bot.send_message(
                        chat_id=manager_id,
                        text=short_text,
                        parse_mode="HTML",
                        reply_markup=keyboard,
                    )
                    sent_ok = True
                except Exception as e:
                    logger.warning("send to manager %s: %s", manager_id, e)
    if not sent_ok:
        await update.message.reply_text("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ–±—Ä–∞—â–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
        return
    # –ö–Ω–æ–ø–∫–∞ ¬´–ó–∞–∫—Ä—ã—Ç—å —Ç–∏–∫–µ—Ç¬ª —É–∂–µ –ø–æ–¥ –æ—Ç–≤–µ—Ç–æ–º –ò–ò ‚Äî –Ω–µ –¥—É–±–ª–∏—Ä—É–µ–º –≤—Ç–æ—Ä—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º
    if not ai_reply:
        close_ticket_kb = InlineKeyboardMarkup([[
            InlineKeyboardButton("‚úÖ –ó–∞–∫—Ä—ã—Ç—å —Ç–∏–∫–µ—Ç (–≤–æ–ø—Ä–æ—Å —Ä–µ—à—ë–Ω)", callback_data="client_close_ticket"),
        ]])
        await update.message.reply_text(
            "‚úÖ –í–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–µ—Ä–µ–¥–∞–Ω–æ –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É. –û—Ç–≤–µ—Ç –ø—Ä–∏–¥–µ—Ç –∑–¥–µ—Å—å –≤ –±–æ—Ç–µ.",
            reply_markup=close_ticket_kb,
        )
    # –ï—Å–ª–∏ –±—ã–ª –æ—Ç–≤–µ—Ç –ò–ò ‚Äî –∫–Ω–æ–ø–∫–∏ —É–∂–µ –ø–æ–¥ –Ω–∏–º, –æ—Ç–¥–µ–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º


async def call_manager_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–ª–∏–µ–Ω—Ç –Ω–∞–∂–∞–ª ¬´–ü–æ–∑–≤–∞—Ç—å –º–µ–Ω–µ–¥–∂–µ—Ä–∞¬ª. –î–∞–ª—å—à–µ –æ—Ç–≤–µ—á–∞–µ—Ç —Ç–æ–ª—å–∫–æ –º–µ–Ω–µ–¥–∂–µ—Ä, –ò–ò –Ω–µ –ø–∏—à–µ—Ç."""
    query = update.callback_query
    if not query:
        return
    await query.answer("–ó–∞–ø—Ä–æ—Å –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –º–µ–Ω–µ–¥–∂–µ—Ä—É.")
    client_id = query.from_user.id if query.from_user else 0
    if not client_id:
        return
    if "support_client_wants_manager" not in context.application.bot_data:
        context.application.bot_data["support_client_wants_manager"] = set()
    context.application.bot_data["support_client_wants_manager"].add(client_id)
    try:
        await context.bot.send_message(
            chat_id=client_id,
            text="‚úÖ –ú–µ–Ω–µ–¥–∂–µ—Ä —É–≤–µ–¥–æ–º–ª—ë–Ω, –æ–∂–∏–¥–∞–π—Ç–µ –æ—Ç–≤–µ—Ç–∞.",
        )
    except Exception as e:
        logger.warning("call_manager reply to client: %s", e)
    topic_by_client = context.application.bot_data.get("support_topic_by_client") or {}
    existing = topic_by_client.get(client_id)
    if existing:
        try:
            await context.bot.send_message(
                chat_id=existing["chat_id"],
                message_thread_id=existing["message_thread_id"],
                text="üë§ <b>–ö–ª–∏–µ–Ω—Ç —Ö–æ—á–µ—Ç —Å–≤—è–∑–∞—Ç—å—Å—è —Å –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º.</b>",
                parse_mode="HTML",
            )
        except Exception as e:
            logger.warning("call_manager to topic: %s", e)
    else:
        for manager_id in ALLOWED_MANAGER_IDS:
            try:
                await context.bot.send_message(
                    chat_id=manager_id,
                    text=f"üë§ –ö–ª–∏–µ–Ω—Ç (ID <code>{client_id}</code>) —Ö–æ—á–µ—Ç —Å–≤—è–∑–∞—Ç—å—Å—è —Å –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º. –ù–∞–ø–∏—à–∏—Ç–µ –µ–º—É –≤ –±–æ—Ç–µ –∏–ª–∏ –ø–æ–ø—Ä–æ—Å–∏—Ç–µ –Ω–∞–ø–∏—Å–∞—Ç—å —Å—é–¥–∞ ‚Äî —Ç–∏–∫–µ—Ç —Å–æ–∑–¥–∞—Å—Ç—Å—è.",
                    parse_mode="HTML",
                )
                break
            except Exception as e:
                logger.warning("call_manager to manager %s: %s", manager_id, e)


async def client_close_ticket_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ö–ª–∏–µ–Ω—Ç –Ω–∞–∂–∞–ª ¬´–ó–∞–∫—Ä—ã—Ç—å —Ç–∏–∫–µ—Ç¬ª ‚Äî –≤ —Ç–æ–ø–∏–∫ –ø–∏—à–µ–º —á—Ç–æ –≤–æ–ø—Ä–æ—Å —Ä–µ—à—ë–Ω, –∑–∞–∫—Ä—ã–≤–∞–µ–º —Ç–æ–ø–∏–∫, —É–≤–µ–¥–æ–º–ª—è–µ–º –∫–ª–∏–µ–Ω—Ç–∞."""
    query = update.callback_query
    if not query:
        return
    client_id = query.from_user.id if query.from_user else 0
    if not client_id:
        try:
            await query.answer("–û—à–∏–±–∫–∞.", show_alert=True)
        except Exception:
            pass
        return
    try:
        await query.answer("–¢–∏–∫–µ—Ç –∑–∞–∫—Ä—ã—Ç.")
    except Exception as e:
        logger.debug("client_close_ticket answer_callback_query: %s", e)
    topic_by_client = context.application.bot_data.get("support_topic_by_client") or {}
    thread_to_client = context.application.bot_data.get("support_thread_to_client") or {}
    existing = topic_by_client.get(client_id)
    if existing:
        try:
            await context.bot.send_message(
                chat_id=existing["chat_id"],
                message_thread_id=existing["message_thread_id"],
                text="‚úÖ <b>–ö–ª–∏–µ–Ω—Ç –∑–∞–∫—Ä—ã–ª —Ç–∏–∫–µ—Ç (–≤–æ–ø—Ä–æ—Å —Ä–µ—à—ë–Ω).</b>",
                parse_mode="HTML",
            )
        except Exception as e:
            logger.warning("client_close_ticket message to topic: %s", e)
        try:
            topic_name = existing.get("topic_name") or ""
            if topic_name:
                closed_name = (topic_name.replace("‚ÅâÔ∏è ", "üî• ", 1))[:128]
                await context.bot.edit_forum_topic(
                    chat_id=existing["chat_id"],
                    message_thread_id=existing["message_thread_id"],
                    name=closed_name,
                )
            await context.bot.close_forum_topic(
                chat_id=existing["chat_id"],
                message_thread_id=existing["message_thread_id"],
            )
        except Exception as e:
            logger.warning("client_close_ticket close_forum_topic: %s", e)
        topic_by_client.pop(client_id, None)
        thread_to_client.pop((existing["chat_id"], existing["message_thread_id"]), None)
    support_has_card = context.application.bot_data.get("support_has_card")
    if isinstance(support_has_card, set):
        support_has_card.discard(client_id)
    support_client_wants_manager = context.application.bot_data.get("support_client_wants_manager")
    if isinstance(support_client_wants_manager, set):
        support_client_wants_manager.discard(client_id)
    try:
        await context.bot.send_message(
            chat_id=client_id,
            text="‚úÖ –¢–∏–∫–µ—Ç –∑–∞–∫—Ä—ã—Ç. –ï—Å–ª–∏ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è –ø–æ–º–æ—â—å ‚Äî –Ω–∞–ø–∏—à–∏—Ç–µ —Å–Ω–æ–≤–∞.",
        )
    except Exception as e:
        logger.warning("client_close_ticket notify client: %s", e)


async def support_card_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Å–µ–∫—Ü–∏–π –≤ –∫–∞—Ä—Ç–æ—á–∫–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ (sup:client_id:section) –∏–ª–∏ –¥–µ–π—Å—Ç–≤–∏–µ (sup_act, sup_hwid)."""
    query = update.callback_query
    if not check_access(update.effective_user.id):
        await query.answer("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.", show_alert=True)
        return
    data = query.data
    support_clients = context.application.bot_data.get("support_clients") or {}

    if data.startswith("sup_act:"):
        # sup_act:client_id:action (reset_traffic | revoke_sub | stop_ai | start_ai | ...)
        parts = data.split(":")
        if len(parts) != 3:
            await query.answer()
            return
        try:
            client_id = int(parts[1])
        except ValueError:
            await query.answer()
            return
        action = parts[2]

        # –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ò–ò / –í–∫–ª—é—á–∏—Ç—å –ò–ò ‚Äî –ø–µ—Ä–µ–π—Ç–∏ –≤ —á–∞—Ç —Å–∞–º–æ–º—É (–Ω–µ —Ç—Ä–µ–±—É–µ—Ç uuid)
        if action == "stop_ai":
            if "support_client_wants_manager" not in context.application.bot_data:
                context.application.bot_data["support_client_wants_manager"] = set()
            context.application.bot_data["support_client_wants_manager"].add(client_id)
            await query.answer("–ò–ò –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –û—Ç–≤–µ—á–∞–π—Ç–µ –≤ —á–∞—Ç–µ —Å–∞–º–∏.")
            sc = support_clients.get(client_id)
            if sc:
                last_data = {"user": sc.get("user"), "subscription": sc.get("subscription"), "hwid_devices": sc.get("hwid_devices", []), "bedolaga_user": sc.get("bedolaga_user")}
                keyboard = build_support_keyboard(client_id, "profile", last_data, ai_stopped=True, support_blocked=client_id in (context.application.bot_data.get("support_blocked_clients") or set()))
                try:
                    await query.edit_message_reply_markup(reply_markup=keyboard)
                except Exception:
                    pass
            return
        if action == "start_ai":
            want_mgr = context.application.bot_data.get("support_client_wants_manager")
            if isinstance(want_mgr, set):
                want_mgr.discard(client_id)
            await query.answer("–ò–ò –≤–∫–ª—é—á—ë–Ω —Å–Ω–æ–≤–∞.")
            sc = support_clients.get(client_id)
            if sc:
                last_data = {"user": sc.get("user"), "subscription": sc.get("subscription"), "hwid_devices": sc.get("hwid_devices", []), "bedolaga_user": sc.get("bedolaga_user")}
                keyboard = build_support_keyboard(client_id, "profile", last_data, ai_stopped=False, support_blocked=client_id in (context.application.bot_data.get("support_blocked_clients") or set()))
                try:
                    await query.edit_message_reply_markup(reply_markup=keyboard)
                except Exception:
                    pass
            return
        if action == "block_support":
            if "support_blocked_clients" not in context.application.bot_data:
                context.application.bot_data["support_blocked_clients"] = set()
            context.application.bot_data["support_blocked_clients"].add(client_id)
            await query.answer("–ö–ª–∏–µ–Ω—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –≤ –ø–æ–¥–¥–µ—Ä–∂–∫–µ ‚Äî –ø–∏—Å–∞—Ç—å —Å—é–¥–∞ –±–æ–ª—å—à–µ –Ω–µ —Å–º–æ–∂–µ—Ç.")
            sc = support_clients.get(client_id)
            if sc:
                last_data = {"user": sc.get("user"), "subscription": sc.get("subscription"), "hwid_devices": sc.get("hwid_devices", []), "bedolaga_user": sc.get("bedolaga_user")}
                keyboard = build_support_keyboard(client_id, "profile", last_data, ai_stopped=client_id in (context.application.bot_data.get("support_client_wants_manager") or set()), support_blocked=True)
                try:
                    await query.edit_message_reply_markup(reply_markup=keyboard)
                except Exception:
                    pass
            return
        if action == "unblock_support":
            blocked = context.application.bot_data.get("support_blocked_clients")
            if isinstance(blocked, set):
                blocked.discard(client_id)
            await query.answer("–ö–ª–∏–µ–Ω—Ç —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω ‚Äî —Å–Ω–æ–≤–∞ –º–æ–∂–µ—Ç –ø–∏—Å–∞—Ç—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.")
            sc = support_clients.get(client_id)
            if sc:
                last_data = {"user": sc.get("user"), "subscription": sc.get("subscription"), "hwid_devices": sc.get("hwid_devices", []), "bedolaga_user": sc.get("bedolaga_user")}
                keyboard = build_support_keyboard(client_id, "profile", last_data, ai_stopped=client_id in (context.application.bot_data.get("support_client_wants_manager") or set()), support_blocked=False)
                try:
                    await query.edit_message_reply_markup(reply_markup=keyboard)
                except Exception:
                    pass
            return

        sc = support_clients.get(client_id)
        if not sc or not (sc.get("user") or {}).get("uuid"):
            await query.answer(
                "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Å–∏—Å—Ç–µ–º–µ Remnawave. –î–æ–±–∞–≤—å—Ç–µ –µ–≥–æ –≤ –ø–∞–Ω–µ–ª—å –∏–ª–∏ –æ–±–Ω–æ–≤–∏—Ç–µ –∫–∞—Ä—Ç–æ—á–∫—É.",
                show_alert=True,
            )
            return
        user_uuid = sc["user"]["uuid"]
        if action == "bedolaga_tx":
            await query.answer("–ó–∞–≥—Ä—É–∑–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π...")
            bedolaga_user = sc.get("bedolaga_user")
            if not bedolaga_user or not bedolaga_user.get("id"):
                try:
                    thread_id = getattr(query.message, "message_thread_id", None)
                    kwargs = {"chat_id": update.effective_chat.id, "text": "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö Bedolaga –¥–ª—è —ç—Ç–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞.", "parse_mode": "HTML"}
                    if thread_id:
                        kwargs["message_thread_id"] = thread_id
                    await context.bot.send_message(**kwargs)
                except Exception as e:
                    logger.warning("send bedolaga_tx error: %s", e)
                return
            transactions = get_bedolaga_transactions(int(bedolaga_user["id"]), limit=30)
            text = _format_bedolaga_transactions_message(transactions)
            try:
                thread_id = getattr(query.message, "message_thread_id", None)
                kwargs = {"chat_id": update.effective_chat.id, "text": text, "parse_mode": "HTML"}
                if thread_id:
                    kwargs["message_thread_id"] = thread_id
                await context.bot.send_message(**kwargs)
            except Exception as e:
                logger.warning("send bedolaga transactions: %s", e)
            return
        if action == "invoice":
            await query.answer()
            manager_id = update.effective_user.id
            payload = {
                "client_id": client_id,
                "manager_id": manager_id,
                "user_uuid": user_uuid,
            }
            context.user_data["awaiting_invoice"] = payload
            _set_awaiting_invoice_by_manager(context, manager_id, payload)
            try:
                chat_id = update.effective_chat.id
                thread_id = getattr(query.message, "message_thread_id", None)
                kwargs = {"chat_id": chat_id, "text": "üí∞ <b>–í—ã—Å—Ç–∞–≤–∏—Ç—å —Å—á—ë—Ç</b>\n\n–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –≤ —Ä—É–±–ª—è—Ö (—á–∏—Å–ª–æ):", "parse_mode": "HTML"}
                if thread_id:
                    kwargs["message_thread_id"] = thread_id
                await context.bot.send_message(**kwargs)
            except Exception as e:
                logger.warning("send invoice prompt to manager: %s", e)
            return
        if action == "squads":
            await query.answer()
            context.user_data["squads_target_uuid"] = user_uuid
            internal = get_internal_squads() or []
            external = get_external_squads() or []
            rows = []
            for s in internal:
                name = (s.get("name") or s.get("uuid", ""))[:32]
                rows.append([InlineKeyboardButton(f"üìÅ {name}", callback_data=f"squad:i:{s.get('uuid', '')}")])
            for s in external:
                name = (s.get("name") or s.get("uuid", ""))[:32]
                rows.append([InlineKeyboardButton(f"üåê {name}", callback_data=f"squad:e:{s.get('uuid', '')}")])
            if not rows:
                try:
                    await query.edit_message_text(
                        sc["support_header"] + "\nüë• <b>–°–∫–≤–∞–¥—ã</b>\n\n–ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–∫–≤–∞–¥–æ–≤.",
                        parse_mode="HTML",
                    )
                except Exception:
                    await context.bot.send_message(
                        chat_id=update.effective_chat.id,
                        text="üë• –ù–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–∫–≤–∞–¥–æ–≤.",
                        reply_to_message_id=query.message.message_id if query.message else None,
                    )
                return
            rows.append([InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="squad_back")])
            text = sc["support_header"] + "\nüë• <b>–í—ã–±–µ—Ä–∏—Ç–µ —Å–∫–≤–∞–¥ –¥–ª—è –≤—ã–¥–∞—á–∏ –∫–ª–∏–µ–Ω—Ç—É:</b>"
            try:
                thread_id = getattr(query.message, "message_thread_id", None)
                kwargs = {"chat_id": update.effective_chat.id, "text": text, "parse_mode": "HTML", "reply_markup": InlineKeyboardMarkup(rows)}
                if thread_id:
                    kwargs["message_thread_id"] = thread_id
                await context.bot.send_message(**kwargs)
            except Exception as e:
                logger.warning("send squads list: %s", e)
            return
        ok, msg = False, ""
        if action == "reset_traffic":
            await query.answer("–°–±—Ä–æ—Å —Ç—Ä–∞—Ñ–∏–∫–∞...")
            ok, msg = api_reset_user_traffic(user_uuid)
        elif action == "revoke_sub":
            await query.answer("–ü–µ—Ä–µ–≤—ã–ø—É—Å–∫ –ø–æ–¥–ø–∏—Å–∫–∏...")
            ok, msg = api_revoke_user_subscription(user_uuid)
        elif action == "disable":
            await query.answer("–ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è...")
            ok, msg = api_disable_user(user_uuid)
        elif action == "enable":
            await query.answer("–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è...")
            ok, msg = api_enable_user(user_uuid)
        elif action == "hwid_all":
            await query.answer("–£–¥–∞–ª–µ–Ω–∏–µ –≤—Å–µ—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤...")
            ok, msg = api_delete_all_hwid(user_uuid)
        else:
            await query.answer()
            return
        api_user = get_user_by_telegram_id(str(client_id))
        subscription = get_subscription_by_uuid(user_uuid) if user_uuid else None
        hwid_devices = get_hwid_devices(user_uuid) if user_uuid else []
        support_clients[client_id] = {
            "user": api_user or sc["user"],
            "subscription": subscription,
            "hwid_devices": hwid_devices,
            "support_header": sc.get("support_header", ""),
            "bedolaga_user": sc.get("bedolaga_user"),
        }
        last_data = {"user": support_clients[client_id]["user"], "subscription": subscription, "hwid_devices": hwid_devices, "bedolaga_user": sc.get("bedolaga_user")}
        section = (
            "traffic" if action == "reset_traffic"
            else ("subscription" if action == "revoke_sub"
                  else ("profile" if action in ("disable", "enable") else "hwid"))
        )
        header_extra = (f"‚úÖ <i>{msg}</i>\n\n" if ok else f"‚ùå <i>{msg}</i>\n\n")
        username_display = last_data["user"].get("username") or "‚Äî"
        data_header = f"‚úÖ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å</b> @{username_display}\n\n{header_extra}"
        section_text = get_section_text(section, last_data["user"], subscription, hwid_devices)
        full_text = sc["support_header"] + data_header + section_text
        ai_stopped = client_id in (context.application.bot_data.get("support_client_wants_manager") or set())
        support_blocked = client_id in (context.application.bot_data.get("support_blocked_clients") or set())
        keyboard = build_support_keyboard(client_id, section, last_data, ai_stopped=ai_stopped, support_blocked=support_blocked)
        try:
            await query.edit_message_text(full_text, parse_mode="HTML", reply_markup=keyboard)
        except Exception as e:
            logger.error("edit support message: %s", e)
        return

    if data.startswith("sup_hwid:"):
        # sup_hwid:client_id:index
        parts = data.split(":")
        if len(parts) != 3:
            await query.answer()
            return
        try:
            client_id = int(parts[1])
            idx = int(parts[2])
        except ValueError:
            await query.answer()
            return
        sc = support_clients.get(client_id)
        if not sc:
            await query.answer("–î–∞–Ω–Ω—ã–µ —É—Å—Ç–∞—Ä–µ–ª–∏.", show_alert=True)
            return
        hwid_devices = sc.get("hwid_devices") or []
        if idx < 0 or idx >= len(hwid_devices):
            await query.answer("–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", show_alert=True)
            return
        hwid = hwid_devices[idx].get("hwid")
        user_uuid = (sc.get("user") or {}).get("uuid")
        if not hwid or not user_uuid:
            await query.answer("–û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö.", show_alert=True)
            return
        await query.answer("–£–¥–∞–ª–µ–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞...")
        ok, msg = api_delete_hwid_device(user_uuid, hwid)
        api_user = get_user_by_telegram_id(str(client_id))
        subscription = get_subscription_by_uuid(user_uuid) if user_uuid else None
        hwid_devices = get_hwid_devices(user_uuid) if user_uuid else []
        support_clients[client_id] = {
            "user": api_user or sc["user"],
            "subscription": subscription,
            "hwid_devices": hwid_devices,
            "support_header": sc.get("support_header", ""),
            "bedolaga_user": sc.get("bedolaga_user"),
        }
        last_data = {"user": support_clients[client_id]["user"], "subscription": subscription, "hwid_devices": hwid_devices, "bedolaga_user": sc.get("bedolaga_user")}
        header_extra = (f"‚úÖ <i>{msg}</i>\n\n" if ok else f"‚ùå <i>{msg}</i>\n\n")
        username_display = last_data["user"].get("username") or "‚Äî"
        data_header = f"‚úÖ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å</b> @{username_display}\n\n{header_extra}"
        section_text = get_section_text("hwid", last_data["user"], subscription, hwid_devices)
        full_text = sc["support_header"] + data_header + section_text
        ai_stopped = client_id in (context.application.bot_data.get("support_client_wants_manager") or set())
        support_blocked = client_id in (context.application.bot_data.get("support_blocked_clients") or set())
        keyboard = build_support_keyboard(client_id, "hwid", last_data, ai_stopped=ai_stopped, support_blocked=support_blocked)
        try:
            await query.edit_message_text(full_text, parse_mode="HTML", reply_markup=keyboard)
        except Exception as e:
            logger.error("edit support message: %s", e)
        return

    # sup:client_id:section ‚Äî –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Å–µ–∫—Ü–∏–∏
    if not data.startswith("sup:"):
        return
    parts = data.split(":", 2)
    if len(parts) != 3:
        await query.answer()
        return
    try:
        client_id = int(parts[1])
        section = parts[2]
    except ValueError:
        await query.answer()
        return
    if section not in SECTIONS:
        await query.answer()
        return
    sc = support_clients.get(client_id)
    if not sc:
        await query.answer("–î–∞–Ω–Ω—ã–µ —É—Å—Ç–∞—Ä–µ–ª–∏.", show_alert=True)
        return
    await query.answer()
    user = sc.get("user") or {}
    subscription = sc.get("subscription")
    hwid_devices = sc.get("hwid_devices") or []
    last_data = {"user": user, "subscription": subscription, "hwid_devices": hwid_devices, "bedolaga_user": sc.get("bedolaga_user")}
    username_display = user.get("username") or "‚Äî"
    data_header = f"‚úÖ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å</b> @{username_display}\n\n"
    section_text = get_section_text(section, user, subscription, hwid_devices)
    full_text = sc.get("support_header", "") + data_header + section_text
    ai_stopped = client_id in (context.application.bot_data.get("support_client_wants_manager") or set())
    support_blocked = client_id in (context.application.bot_data.get("support_blocked_clients") or set())
    keyboard = build_support_keyboard(client_id, section, last_data, ai_stopped=ai_stopped, support_blocked=support_blocked)
    try:
        await query.edit_message_text(full_text, parse_mode="HTML", reply_markup=keyboard)
    except Exception as e:
        logger.error("edit support message: %s", e)


async def squad_assign_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–í—ã–¥–∞—á–∞ —Å–∫–≤–∞–¥–∞ –∫–ª–∏–µ–Ω—Ç—É: squad:i:uuid, squad:e:uuid –∏–ª–∏ squad_back (–ù–∞–∑–∞–¥/–ó–∞–∫—Ä—ã—Ç—å)."""
    query = update.callback_query
    if not check_access(update.effective_user.id):
        await query.answer("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.", show_alert=True)
        return
    if query.data == "squad_back":
        await query.answer()
        try:
            await query.message.delete()
        except Exception as e:
            logger.debug("delete squads message: %s", e)
        return
    user_uuid = context.user_data.get("squads_target_uuid")
    if not user_uuid:
        await query.answer("–°–µ—Å—Å–∏—è –∏—Å—Ç–µ–∫–ª–∞. –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∑–∞–Ω–æ–≤–æ –∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–°–∫–≤–∞–¥—ã¬ª.", show_alert=True)
        return
    parts = query.data.split(":", 2)
    if len(parts) != 3:
        await query.answer()
        return
    squad_type, squad_uuid = parts[1], parts[2]
    if not squad_uuid:
        await query.answer("–û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö.", show_alert=True)
        return
    if squad_type == "i":
        await query.answer("–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Å–∫–≤–∞–¥...")
        ok, msg = add_user_to_internal_squad(squad_uuid, user_uuid)
    elif squad_type == "e":
        await query.answer("–í—ã–¥–∞—á–∞ —Å–∫–≤–∞–¥–∞ –∫–ª–∏–µ–Ω—Ç—É...")
        ok, msg = add_user_to_external_squad(squad_uuid, user_uuid)
    else:
        await query.answer()
        return
    context.user_data.pop("squads_target_uuid", None)
    close_btn = InlineKeyboardMarkup([[
        InlineKeyboardButton("‚óÄÔ∏è –ó–∞–∫—Ä—ã—Ç—å", callback_data="squad_back"),
    ]])
    try:
        await query.edit_message_text(
            (query.message.text or "") + f"\n\n{'‚úÖ' if ok else '‚ùå'} {msg}",
            parse_mode="HTML",
            reply_markup=close_btn,
        )
    except Exception:
        try:
            thread_id = getattr(query.message, "message_thread_id", None) if query.message else None
            kwargs = {
                "chat_id": update.effective_chat.id,
                "text": f"{'‚úÖ' if ok else '‚ùå'} {msg}",
                "reply_markup": close_btn,
            }
            if thread_id:
                kwargs["message_thread_id"] = thread_id
            elif query.message:
                kwargs["reply_to_message_id"] = query.message.message_id
            await context.bot.send_message(**kwargs)
        except Exception as e:
            logger.warning("send squad result: %s", e)


async def close_ticket_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ó–∞–∫—Ä—ã—Ç–∏–µ —Ç–∏–∫–µ—Ç–∞: –∑–∞–∫—Ä—ã–≤–∞–µ–º —Ç–æ–ø–∏–∫ –≤ –≥—Ä—É–ø–ø–µ, —É–≤–µ–¥–æ–º–ª—è–µ–º –∫–ª–∏–µ–Ω—Ç–∞, –æ—á–∏—â–∞–µ–º –º–∞–ø–ø–∏–Ω–≥."""
    query = update.callback_query
    if not check_access(update.effective_user.id):
        await query.answer("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.", show_alert=True)
        return
    if not query.data.startswith("close_ticket:"):
        return
    try:
        client_id = int(query.data.split(":")[1])
    except (IndexError, ValueError):
        await query.answer()
        return
    # –°—Ä–∞–∑—É –æ—Ç–≤–µ—á–∞–µ–º Telegram (–∏–Ω–∞—á–µ ¬´Query is too old¬ª –ø—Ä–∏ –¥–æ–ª–≥–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏—è—Ö)
    try:
        await query.answer("–¢–∏–∫–µ—Ç –∑–∞–∫—Ä—ã—Ç. –ö–ª–∏–µ–Ω—Ç —É–≤–µ–¥–æ–º–ª—ë–Ω.")
    except Exception as e:
        logger.debug("close_ticket answer_callback_query: %s", e)
    topic_by_client = context.application.bot_data.get("support_topic_by_client") or {}
    thread_to_client = context.application.bot_data.get("support_thread_to_client") or {}
    existing = topic_by_client.get(client_id)
    if existing:
        try:
            topic_name = existing.get("topic_name") or ""
            if topic_name:
                closed_name = (topic_name.replace("‚ÅâÔ∏è ", "üî• ", 1))[:128]
                await context.bot.edit_forum_topic(
                    chat_id=existing["chat_id"],
                    message_thread_id=existing["message_thread_id"],
                    name=closed_name,
                )
            await context.bot.close_forum_topic(
                chat_id=existing["chat_id"],
                message_thread_id=existing["message_thread_id"],
            )
        except Exception as e:
            logger.warning("close_forum_topic / edit_forum_topic: %s", e)
        topic_by_client.pop(client_id, None)
        thread_to_client.pop((existing["chat_id"], existing["message_thread_id"]), None)
    support_has_card = context.application.bot_data.get("support_has_card")
    if isinstance(support_has_card, set):
        support_has_card.discard(client_id)
    support_client_wants_manager = context.application.bot_data.get("support_client_wants_manager")
    if isinstance(support_client_wants_manager, set):
        support_client_wants_manager.discard(client_id)
    try:
        await context.bot.send_message(
            chat_id=client_id,
            text="‚úÖ –¢–∏–∫–µ—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∑–∞–∫—Ä—ã—Ç.\n\n–í—ã –º–æ–∂–µ—Ç–µ –Ω–∞–ø–∏—Å–∞—Ç—å –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ª—é–±–æ–µ –≤—Ä–µ–º—è.",
        )
    except Exception as e:
        logger.debug("notify client ticket closed: %s", e)
    try:
        await query.edit_message_text("‚úÖ –¢–∏–∫–µ—Ç –∑–∞–∫—Ä—ã—Ç. –ö–ª–∏–µ–Ω—Ç —É–≤–µ–¥–æ–º–ª—ë–Ω.")
    except Exception:
        pass


async def handle_support_group_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–°–æ–æ–±—â–µ–Ω–∏—è –≤ –≥—Ä—É–ø–ø–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –≤ —Ç–æ–ø–∏–∫–µ: –æ—Ç–≤–µ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞ (—Ç–µ–∫—Å—Ç/—Ñ–æ—Ç–æ/—Ñ–∞–π–ª) –ø–µ—Ä–µ—Å—ã–ª–∞–µ–º –∫–ª–∏–µ–Ω—Ç—É."""
    if not update.message:
        return
    allowed_chat_ids = set(_support_chat_ids())
    if not allowed_chat_ids or update.effective_chat.id not in allowed_chat_ids:
        return
    # –ï—Å–ª–∏ –º–µ–Ω–µ–¥–∂–µ—Ä –≤–≤—ë–ª —Å—É–º–º—É –¥–ª—è ¬´–í—ã—Å—Ç–∞–≤–∏—Ç—å —Å—á—ë—Ç¬ª ‚Äî –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∫ –≤—ã—Å—Ç–∞–≤–ª–µ–Ω–∏–µ —Å—á—ë—Ç–∞, –Ω–µ –ø–µ—Ä–µ—Å—ã–ª–∞–µ–º –∫–ª–∏–µ–Ω—Ç—É
    manager_id = update.effective_user.id
    if check_access(manager_id) and _get_awaiting_invoice(context, manager_id):
        if await _handle_invoice_amount(update, context):
            return
    content = _get_message_content(update)
    if not content:
        return
    thread_id = getattr(update.message, "message_thread_id", None)
    if not thread_id:
        return
    thread_to_client = context.application.bot_data.get("support_thread_to_client") or {}
    client_id = thread_to_client.get((update.effective_chat.id, thread_id))
    if not client_id:
        return
    if not check_access(update.effective_user.id):
        return
    if getattr(update.effective_user, "is_bot", False):
        return
    manager_name = update.effective_user.first_name or "–ü–æ–¥–¥–µ—Ä–∂–∫–∞"
    await _forward_content_to_client(context, client_id, content, manager_name)
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ç–≤–µ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–∞ –≤ –∏—Å—Ç–æ—Ä–∏—é –∏ –≤ –≥–ª–æ–±–∞–ª—å–Ω—ã–π –ø—É–ª –ø—Ä–∏–º–µ—Ä–æ–≤ (LLM –æ–±—É—á–∞–µ—Ç—Å—è –Ω–∞ –≤—Å–µ—Ö —á–∞—Ç–∞—Ö)
    if _AI_SUPPORT_AVAILABLE and add_to_conversation_history:
        manager_text = None
        if content[0] in ("text", "caption_only") and (content[1] or "").strip():
            manager_text = (content[1] or "").strip()
            add_to_conversation_history(context.application.bot_data, client_id, "assistant", manager_text)
        elif content[0] == "photo" and (len(content) > 2 and (content[2] or "").strip()):
            manager_text = "–ú–µ–Ω–µ–¥–∂–µ—Ä –æ—Ç–ø—Ä–∞–≤–∏–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. " + (content[2] or "").strip()
            add_to_conversation_history(context.application.bot_data, client_id, "assistant", manager_text)
        elif content[0] not in ("text", "caption_only", "photo"):
            add_to_conversation_history(context.application.bot_data, client_id, "assistant", "[–ú–µ–Ω–µ–¥–∂–µ—Ä –æ—Ç–ø—Ä–∞–≤–∏–ª –≤–ª–æ–∂–µ–Ω–∏–µ]")
        if manager_text and add_global_example and get_last_user_message:
            last_user = get_last_user_message(context.application.bot_data, client_id)
            if last_user:
                add_global_example(context.application.bot_data, last_user, manager_text)


async def _handle_invoice_amount(update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ —Å—É–º–º—ã –¥–ª—è –≤—ã—Å—Ç–∞–≤–ª–µ–Ω–∏—è —Å—á—ë—Ç–∞. –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç True, –µ—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ."""
    manager_id = update.effective_user.id
    awaiting = _get_awaiting_invoice(context, manager_id)
    if not awaiting:
        return False
    text = (update.message.text or "").strip()
    try:
        amount = float(text.replace(",", "."))
    except ValueError:
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ (—Å—É–º–º—É –≤ —Ä—É–±–ª—è—Ö).")
        return True
    if amount <= 0:
        await update.message.reply_text("–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ 0.")
        return True
    _clear_awaiting_invoice(context, manager_id)
    client_id = awaiting.get("client_id")
    manager_id = awaiting.get("manager_id")
    user_uuid = awaiting.get("user_uuid")
    if not _PAYMENTS_AVAILABLE or not get_freekassa_provider:
        await update.message.reply_text("–ü–ª–∞—Ç—ë–∂–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞ (Freekassa).")
        return True
    provider = get_freekassa_provider()
    if not provider:
        await update.message.reply_text("–ü–ª–∞—Ç—ë–∂–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∞ (Freekassa API key / shop ID).")
        return True
    payment_id = f"rmb_{int(time.time() * 1000)}_{client_id or manager_id}"
    email = f"{client_id}@telegram.org" if client_id else f"{manager_id}@telegram.org"
    base_url = (os.getenv("PAYMENTS_BASE_URL") or os.getenv("MINI_APP_DOMAIN") or "").strip()
    if base_url:
        if base_url.startswith("https:/") and not base_url.startswith("https://"):
            base_url = "https://" + base_url[7:]
        elif base_url.startswith("http:/") and not base_url.startswith("http://"):
            base_url = "http://" + base_url[6:]
        elif "://" not in base_url:
            base_url = "https://" + base_url
    notification_url = f"{base_url.rstrip('/')}/webhook/freekassa" if base_url else None
    result = provider.create_invoice(
        amount=amount,
        currency="RUB",
        payment_id=payment_id,
        email=email,
        ip="127.0.0.1",
        client_id=client_id or 0,
        manager_id=manager_id,
        user_uuid=user_uuid,
        notification_url=notification_url,
    )
    if not result.success:
        await update.message.reply_text(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å—á—ë—Ç–∞: {result.error or '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'}.")
        return True
    if pending_add:
        pending_add(
            payment_id=payment_id,
            manager_id=manager_id,
            client_id=client_id if client_id is not None else 0,
            amount=amount,
            currency="RUB",
            user_uuid=user_uuid,
            provider="freekassa",
        )
    if client_id and result.payment_url:
        try:
            await context.bot.send_message(
                chat_id=client_id,
                text=f"üí∞ <b>–°—á—ë—Ç –Ω–∞ –æ–ø–ª–∞—Ç—É</b>\n\n–°—É–º–º–∞: <b>{amount:.2f} ‚ÇΩ</b>\n\n–û–ø–ª–∞—Ç–∏—Ç—å: {result.payment_url}",
                parse_mode="HTML",
            )
        except Exception as e:
            logger.warning("send invoice link to client: %s", e)
    if result.payment_url:
        await update.message.reply_text(
            f"‚úÖ –°—á—ë—Ç –Ω–∞ <b>{amount:.2f} ‚ÇΩ</b> –≤—ã—Å—Ç–∞–≤–ª–µ–Ω.\n\n"
            + ("–°—Å—ã–ª–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –∫–ª–∏–µ–Ω—Ç—É." if client_id else f"–°—Å—ã–ª–∫–∞ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞: {result.payment_url}"),
            parse_mode="HTML",
        )
    else:
        await update.message.reply_text("–°—á—ë—Ç —Å–æ–∑–¥–∞–Ω, –Ω–æ —Å—Å—ã–ª–∫–∞ –Ω–µ –ø–æ–ª—É—á–µ–Ω–∞.")
    return True


async def dispatch_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ú–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ü–∏—è: –º–µ–Ω–µ–¥–∂–µ—Ä ‚Äî –ø–æ–∏—Å–∫; –∫–ª–∏–µ–Ω—Ç ‚Äî –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É (—Ç–µ–∫—Å—Ç/—Ñ–æ—Ç–æ/—Ñ–∞–π–ª). –û—Ç–≤–µ—Ç—ã –≤ —Ç–æ–ø–∏–∫–∞—Ö ‚Äî handle_support_group_message."""
    if not update.message:
        return
    user_id = update.effective_user.id

    if check_access(user_id):
        if _get_awaiting_invoice(context, user_id):
            if await _handle_invoice_amount(update, context):
                return
        if update.message.text:
            await handle_message(update, context)
        return

    await handle_client_message(update, context)


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /help"""
    user_id = update.effective_user.id

    if not check_access(user_id):
        try:
            await context.bot.set_chat_menu_button(
                chat_id=update.effective_chat.id,
                menu_button=MenuButtonCommands(),
            )
        except Exception as e:
            logger.debug("set_chat_menu_button commands: %s", e)
        await update.message.reply_text("–ù–∞–ø–∏—à–∏—Ç–µ –≤–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ ‚Äî –º–µ–Ω–µ–¥–∂–µ—Ä –æ—Ç–≤–µ—Ç–∏—Ç –∑–¥–µ—Å—å.")
        return
    
    text = (
        "üìñ <b>–°–ø—Ä–∞–≤–∫–∞</b>\n\n"
        "üîç <b>–ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:</b>\n"
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ Telegram ID (—á–∏—Å–ª–æ) –∏–ª–∏ username (—Å @ –∏–ª–∏ –±–µ–∑) –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n\n"
        "üìã <b>–ß—Ç–æ –≤—ã –ø–æ–ª—É—á–∏—Ç–µ:</b>\n"
        "‚Ä¢ –ü–æ–ª–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ\n"
        "‚Ä¢ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç—Ä–∞—Ñ–∏–∫–∞\n"
        "‚Ä¢ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–¥–ø–∏—Å–∫–µ\n"
        "‚Ä¢ –ü—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ (HWID)\n"
        "‚Ä¢ –î–∞—Ç—ã —Å–æ–∑–¥–∞–Ω–∏—è, –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è, –∏—Å—Ç–µ—á–µ–Ω–∏—è\n\n"
        "üí° <b>–ö–æ–º–∞–Ω–¥—ã:</b>\n"
        "/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É\n"
        "/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É"
    )
    reply_markup = None
    if MINI_APP_URL:
        text += "\n\nüì± –ò–ª–∏ –æ—Ç–∫—Ä–æ–π—Ç–µ <b>–º–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ</b> ‚Äî —Ç–∞–º —Ç–æ—Ç –∂–µ –ø–æ–∏—Å–∫ –≤ —É–¥–æ–±–Ω–æ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ."
        reply_markup = InlineKeyboardMarkup([[
            InlineKeyboardButton("üì± –û—Ç–∫—Ä—ã—Ç—å –º–∏–Ω–∏-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ", web_app=WebAppInfo(url=MINI_APP_URL))
        ]])
    await update.message.reply_text(text, parse_mode='HTML', reply_markup=reply_markup)


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
    user_id = update.effective_user.id
    
    if not check_access(user_id):
        await update.message.reply_text(
            "‚ùå –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É.\n"
            "–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ—Å—Ç—É–ø–∞."
        )
        return
    
    query = update.message.text.strip()
    
    if not query:
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ Telegram ID –∏–ª–∏ username.")
        return
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏
    processing_msg = await update.message.reply_text("‚è≥ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –∑–∞–ø—Ä–æ—Å...")
    
    user = None
    subscription = None
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º, —á—Ç–æ —ç—Ç–æ: Telegram ID –∏–ª–∏ username
    if query.isdigit():
        # –≠—Ç–æ Telegram ID
        logger.info(f"–ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ Telegram ID: {query}")
        user = get_user_by_telegram_id(query)
    else:
        # –≠—Ç–æ username (—É–±–∏—Ä–∞–µ–º @ –µ—Å–ª–∏ –µ—Å—Ç—å)
        username = query.lstrip('@')
        logger.info(f"–ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ username: {username}")
        user = get_user_by_username(username)
    
    if not user:
        await processing_msg.edit_text(
            f"‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.\n\n"
            f"–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –≤–≤–µ–¥–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö:\n"
            f"‚Ä¢ Telegram ID –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º\n"
            f"‚Ä¢ Username –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤"
        )
        return
    
    user_uuid = user.get('uuid')
    subscription = None
    hwid_devices = None
    if user_uuid:
        subscription = get_subscription_by_uuid(user_uuid)
        hwid_devices = get_hwid_devices(user_uuid)
    
    telegram_id_for_bedolaga = user.get("telegramId") or (query if query.isdigit() else None)
    bedolaga_user = get_bedolaga_user(str(telegram_id_for_bedolaga)) if telegram_id_for_bedolaga and _bedolaga_configured() else None
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏ –ø–æ –∫–Ω–æ–ø–∫–∞–º
    context.user_data["last_user_data"] = {
        "user": user,
        "subscription": subscription,
        "hwid_devices": hwid_devices,
        "bedolaga_user": bedolaga_user,
    }
    
    try:
        await processing_msg.delete()
        username_display = user.get('username', 'N/A')
        header = f"‚úÖ <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å</b> @{username_display}\n\n"
        if bedolaga_user:
            balance_str = _format_bedolaga_balance(bedolaga_user)
            header += f"üí∞ <b>–ë–∞–ª–∞–Ω—Å (Bedolaga):</b> {balance_str} ‚ÇΩ\n\n"
        section_text = get_section_text("profile", user, subscription, hwid_devices)
        full_text = header + section_text
        keyboard = build_section_keyboard("profile", context.user_data["last_user_data"])
        await update.message.reply_text(
            full_text,
            parse_mode="HTML",
            reply_markup=keyboard,
        )
        if MINI_APP_URL:
            try:
                await context.bot.set_chat_menu_button(
                    chat_id=update.effective_chat.id,
                    menu_button=MenuButtonWebApp(text="üì± –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ", web_app=WebAppInfo(url=MINI_APP_URL)),
                )
            except Exception as e:
                logger.debug("set_chat_menu_button: %s", e)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}")
        await update.message.reply_text(
            f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞.\n–û—à–∏–±–∫–∞: {str(e)}"
        )


async def post_init(application: Application) -> None:
    """–ì–ª–æ–±–∞–ª—å–Ω–∞—è –∫–Ω–æ–ø–∫–∞ –º–µ–Ω—é ‚Äî ¬´–ö–æ–º–∞–Ω–¥—ã¬ª. –ö–Ω–æ–ø–∫—É Mini App —Å—Ç–∞–≤–∏–º —Ç–æ–ª—å–∫–æ –º–µ–Ω–µ–¥–∂–µ—Ä–∞–º –ø—Ä–∏ /start –∏ –ø–æ–∏—Å–∫–µ."""
    try:
        await application.bot.set_chat_menu_button(menu_button=MenuButtonCommands())
    except Exception as e:
        logger.warning("post_init set_chat_menu_button: %s", e)


def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞"""
    logger.info("–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞...")

    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –º–µ–∂–¥—É –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–º–∏ (—Ç–æ–ø–∏–∫–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∏, —Å—á—ë—Ç—á–∏–∫ —Ç–∏–∫–µ—Ç–æ–≤, user_data)
    persistence_path = os.getenv("PERSISTENCE_PATH", "/data/bot_state.pickle")
    try:
        persistence = PicklePersistence(filepath=persistence_path)
        logger.info("Persistence: %s", persistence_path)
    except Exception as e:
        logger.warning("Persistence –æ—Ç–∫–ª—é—á–µ–Ω–∞ (%s): %s", persistence_path, e)
        persistence = None

    builder = Application.builder().token(BOT_TOKEN).post_init(post_init)
    if persistence:
        builder = builder.persistence(persistence)
    application = builder.build()
    
    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CallbackQueryHandler(support_card_callback, pattern="^sup"))
    application.add_handler(CallbackQueryHandler(close_ticket_callback, pattern="^close_ticket:"))
    application.add_handler(CallbackQueryHandler(call_manager_callback, pattern="^call_manager$"))
    application.add_handler(CallbackQueryHandler(client_close_ticket_callback, pattern="^client_close_ticket$"))
    application.add_handler(CallbackQueryHandler(squad_assign_callback, pattern="^squad"))
    application.add_handler(CallbackQueryHandler(action_callback, pattern="^(act:|hwid_del:)"))
    application.add_handler(CallbackQueryHandler(button_callback, pattern="^s:"))
    # –¢–µ–∫—Å—Ç, —Ñ–æ—Ç–æ, –¥–æ–∫—É–º–µ–Ω—Ç—ã –∏ —Ç.–¥. –≤ –≥—Ä—É–ø–ø–µ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ (—Ç–æ–ø–∏–∫–∏)
    support_content = (
        filters.TEXT | filters.PHOTO | filters.Document.ALL
        | filters.VIDEO | filters.VOICE | filters.AUDIO
    ) & ~filters.COMMAND
    if SUPPORT_GROUP_ID:
        support_chat_ids = _support_chat_ids()
        application.add_handler(MessageHandler(
            support_content & filters.Chat(support_chat_ids),
            handle_support_group_message,
        ))
    # –¢–µ–∫—Å—Ç, —Ñ–æ—Ç–æ, –¥–æ–∫—É–º–µ–Ω—Ç—ã –æ—Ç –∫–ª–∏–µ–Ω—Ç–æ–≤; —Ç–µ–∫—Å—Ç –æ—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ (–ø–æ–∏—Å–∫)
    application.add_handler(MessageHandler(support_content, dispatch_message))
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª—é—á–∞ –ò–ò (Groq –∏–ª–∏ Gemini) –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ (–≤–∏–¥–Ω–æ –≤ –ª–æ–≥–∞—Ö: OK –∏–ª–∏ –æ—à–∏–±–∫–∞)
    if _AI_SUPPORT_AVAILABLE and is_ai_enabled():
        check_ai_key_at_startup()
    # –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
    logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ")
    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == '__main__':
    main()